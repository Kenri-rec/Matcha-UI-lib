-- UILib.lua
-- Full UI library (Drawing API), extracted from user's file (examples removed)
-- Keep Drawing/Color3 etc. as in original

UILib = {}
UILib.__index = UILib

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- small helpers
local function clamp(val, minv, maxv)
    if val < minv then return minv end
    if val > maxv then return maxv end
    return val
end

local function getMousePos()
    return Vector2.new(Mouse.X, Mouse.Y)
end

function UILib._IsMouseWithinBounds(pos, size)
    local m = getMousePos()
    return pos and size and m.X >= pos.x and m.x <= pos.x + size.x and m.y >= pos.y and m.y <= pos.y + size.y
end

-- Internal defaults / style
local VISIBLE = true
local winX, winY = 200, 200
local winW, winH = 600, 350
local tabW, tabH = 100, 30
local spacing = 10
local controlW, controlH = 420, 35
local sliderW = 120
local checkboxSize = 20
local smallPad = 25

local COLOR_BG = Color3.fromRGB(20, 20, 20)
local COLOR_ACCENT = Color3.fromRGB(106, 0, 255)
local COLOR_PANEL = Color3.fromRGB(30, 30, 30)
local COLOR_TEXT = Color3.fromRGB(255, 255, 255)
local COLOR_PANEL2 = Color3.fromRGB(40, 40, 40)
local COLOR_HOVER = Color3.fromRGB(50, 50, 50)

-- Input and state trackers
local dragging = false
local dragOffset = Vector2.new(0,0)
local mouseDownLast = false
local mouseDown = false
local mouseClick = false
local mouseHold = false
local keyStates = {}
local keyDownLatency = {}
local keyLastPress = {}

-- global UI maps
local hoverMap = {}
local tabHoverMap = {}
local dropDownState = {}
local globalZ_BASE = 1000
local Z_WINDOW = globalZ_BASE + 1000
local Z_CONTROLS = globalZ_BASE + 2000
local Z_DROPDOWN_BASE = 8000
local Z_DROPDOWN_OPTIONS = 9000
local Z_COLOR_PICKER = 10000

-- keyboard map (partial, used to translate names)
local KEYMAP = {
    A = 0x41, B = 0x42, C = 0x43, D = 0x44, E = 0x45, F = 0x46, G = 0x47, H = 0x48, I = 0x49,
    J = 0x4A, K = 0x4B, L = 0x4C, M = 0x4D, N = 0x4E, O = 0x4F, P = 0x50, Q = 0x51, R = 0x52,
    S = 0x53, T = 0x54, U = 0x55, V = 0x56, W = 0x57, X = 0x58, Y = 0x59, Z = 0x5A,
    M1 = 0x01, M2 = 0x02, ["1"] = 0x31, ["2"] = 0x32, ["3"] = 0x33, ["4"] = 0x34, ["5"] = 0x35,
    ["6"] = 0x36, ["7"] = 0x37, ["8"] = 0x38, ["9"] = 0x39, ["0"] = 0x30,
    SHIFT = 0x10, RSHIFT = 0xA1, CONTROL = 0x11, RCONTROL = 0xA3,
    BACKSPACE = 0x08, SPACE = 0x20, ENTER = 0x0D, TAB = 0x09, ESCAPE = 0x1B
}

local function keyNameFromCode(code)
    for name, c in pairs(KEYMAP) do
        if c == code then return name end
    end
    return nil
end

-- key utilities (using iskeypressed/isrbxactive which are typically provided by executors)
local function keyDownEdge(keyCode)
    if iskeypressed(keyCode) then
        if keyStates[keyCode] then
            keyStates[keyCode] = true
            return false
        else
            keyStates[keyCode] = true
            return true
        end
    else
        keyStates[keyCode] = false
        return false
    end
end

local function keyPressedAutoRepeat(keyCode)
    -- slightly more advanced: first press true, then repeat every interval while held
    if not isrbxactive() then return false end
    local now = os.clock()
    local last = keyLastPress[keyCode]
    if iskeypressed(keyCode) then
        if not last then
            keyLastPress[keyCode] = now
            return true
        else
            -- allow repeat after initial delay
            local repeatDelay = 0.4
            local repeatStep = 0.05
            local elapsed = now - last
            if elapsed >= repeatDelay then
                local steps = math.floor((elapsed - repeatDelay) / repeatStep)
                local nextTime = last + repeatDelay + steps * repeatStep
                if now - nextTime >= repeatStep then
                    -- allow
                    keyLastPress[keyCode] = now
                    return true
                end
            end
        end
    else
        keyLastPress[keyCode] = nil
    end
    return false
end

-- color conversion helpers (RGB <-> HSV-like helpers as present in original)
local function hsvToRgb(h, s, v)
    if s <= 0 then
        local r = v; return r*255, r*255, r*255
    end
    h = h * 6
    local c = v * s
    local x = c * (1 - math.abs(h % 2 - 1))
    local m = v - c
    local r,g,b = 0,0,0
    if h < 1 then r,g,b = c,x,0
    elseif h < 2 then r,g,b = x,c,0
    elseif h < 3 then r,g,b = 0,c,x
    elseif h < 4 then r,g,b = 0,x,c
    elseif h < 5 then r,g,b = x,0,c
    else r,g,b = c,0,x end
    return math.floor((r + m)*255), math.floor((g + m)*255), math.floor((b + m)*255)
end

local function rgbToHsv(r,g,b)
    r = r/255; g = g/255; b = b/255
    local maxv = math.max(r,g,b); local minv = math.min(r,g,b)
    local d = maxv - minv
    local h = 0
    if d == 0 then h = 0
    elseif maxv == r then h = (g - b) / d % 6
    elseif maxv == g then h = (b - r) / d + 2
    else h = (r - g) / d + 4 end
    h = h/6
    local s = (maxv == 0) and 0 or d / maxv
    local v = maxv
    return h, s, v
end

-- CreateWindow
function UILib:CreateWindow(opts)
    local self = setmetatable({}, UILib)
    self.tabs = {}
    self.activeTab = nil
    self.name = (opts and opts.Name) or "Window"
    self.loadingTitle = (opts and opts.LoadingTitle) or "Loading..."
    self.loadingSubtitle = (opts and opts.LoadingSubtitle) or ""
    self.theme = (opts and opts.Theme) or "Default"
    self.toggleKey = (opts and opts.ToggleUIKeybind) or "K"
    self.minimized = false
    self.notifications = {}

    -- drawing base
    self.base = Drawing.new("Square")
    self.base.Size = Vector2.new(winW, winH)
    self.base.Position = Vector2.new(winX, winY)
    self.base.Filled = true
    self.base.Color = COLOR_BG
    self.base.Visible = VISIBLE
    self.base.Corner = 7
    self.base.ZIndex = Z_WINDOW

    -- close / minimize UI elements
    self.closeBox = Drawing.new("Square")
    self.closeBox.Size = Vector2.new(25,25)
    self.closeBox.Position = Vector2.new(winX + winW - 30, winY + 5)
    self.closeBox.Filled = true
    self.closeBox.Color = COLOR_PANEL2
    self.closeBox.Visible = false
    self.closeBox.Corner = 5
    self.closeBox.ZIndex = Z_WINDOW + 1

    self.closeLine1 = Drawing.new("Line")
    self.closeLine1.From = Vector2.new(winX + winW - 25, winY + 10)
    self.closeLine1.To = Vector2.new(winX + winW - 10, winY + 25)
    self.closeLine1.Color = COLOR_TEXT
    self.closeLine1.Thickness = 2
    self.closeLine1.Visible = VISIBLE
    self.closeLine1.ZIndex = Z_WINDOW + 2

    self.closeLine2 = Drawing.new("Line")
    self.closeLine2.From = Vector2.new(winX + winW - 25, winY + 25)
    self.closeLine2.To = Vector2.new(winX + winW - 10, winY + 10)
    self.closeLine2.Color = COLOR_TEXT
    self.closeLine2.Thickness = 2
    self.closeLine2.Visible = VISIBLE
    self.closeLine2.ZIndex = Z_WINDOW + 2

    self.minimizeBox = Drawing.new("Square")
    self.minimizeBox.Size = Vector2.new(25,25)
    self.minimizeBox.Position = Vector2.new(winX + winW - 60, winY + 5)
    self.minimizeBox.Filled = true
    self.minimizeBox.Color = COLOR_PANEL2
    self.minimizeBox.Visible = false
    self.minimizeBox.Corner = 5
    self.minimizeBox.ZIndex = Z_WINDOW + 1

    self.minimizeLine = Drawing.new("Line")
    self.minimizeLine.From = Vector2.new(winX + winW - 55, winY + 17)
    self.minimizeLine.To = Vector2.new(winX + winW - 40, winY + 17)
    self.minimizeLine.Color = COLOR_TEXT
    self.minimizeLine.Thickness = 2
    self.minimizeLine.Visible = VISIBLE
    self.minimizeLine.ZIndex = Z_WINDOW + 2

    self.title = Drawing.new("Text")
    self.title.Text = self.name
    self.title.Position = Vector2.new(winX + 10, winY + 10)
    self.title.Color = COLOR_TEXT
    self.title.Visible = VISIBLE
    self.title.ZIndex = Z_WINDOW + 2

    -- create tab helper closure (attached to window instance)
    function self:CreateTab(tabName)
        local index = #self.tabs + 1
        local tabY = winY + 50 + (index - 1) * (tabH + spacing)
        local id = "tab_" .. index

        local tabSquare = Drawing.new("Square")
        tabSquare.Size = Vector2.new(tabW, tabH)
        tabSquare.Position = Vector2.new(winX + 10, tabY)
        tabSquare.Filled = true
        tabSquare.Color = COLOR_PANEL
        tabSquare.Visible = VISIBLE
        tabSquare.Corner = 5
        tabSquare.ZIndex = Z_CONTROLS

        local tabText = Drawing.new("Text")
        tabText.Text = tabName
        tabText.Position = Vector2.new(winX + 20, tabY + 8)
        tabText.Color = COLOR_TEXT
        tabText.Visible = VISIBLE
        tabText.ZIndex = Z_CONTROLS + 1

        local tabIndicator = Drawing.new("Square")
        tabIndicator.Size = Vector2.new(7,20)
        tabIndicator.Position = Vector2.new(winX + 10, tabY + 5)
        tabIndicator.Filled = true
        tabIndicator.Color = COLOR_ACCENT
        tabIndicator.Visible = false
        tabIndicator.Corner = 5
        tabIndicator.ZIndex = Z_CONTROLS + 1

        local tab = {
            index = index,
            id = id,
            name = tabName,
            tab = tabSquare,
            label = tabText,
            indicator = tabIndicator,
            pos = Vector2.new(winX + 10, tabY),
            size = Vector2.new(tabW, tabH),
            items = {}
        }

        function tab:CreateButton(info)
            return UILib:CreateButton(self, info.Name, info.Callback)
        end
        function tab:CreateToggle(info)
            return UILib:CreateToggle(self, info.Name, info.CurrentValue, info.Callback)
        end
        function tab:CreateSlider(info)
            return UILib:CreateSlider(self, info.Name, info.Range[1], info.Range[2], info.CurrentValue, info.Increment, info.Callback)
        end
        function tab:CreateDropdown(info)
            return UILib:CreateDropdown(self, info.Name, info.Options, (info.CurrentOption and info.CurrentOption[1]) or nil, info.Callback, info.MultipleOptions)
        end
        function tab:CreateTextbox(info)
            return UILib:CreateTextbox(self, info.Name, info.Default, info.PlaceholderText, info.ClearTextOnFocus, info.Callback)
        end
        function tab:CreateColorPicker(info)
            return UILib:CreateColorPicker(self, info.Name, info.Default, info.Callback)
        end

        tabHoverMap[id] = false
        table.insert(self.tabs, tab)
        if not self.activeTab then
            self.activeTab = tab
            tabIndicator.Visible = true
        end
        return tab
    end

    return self
end

-- CreateButton
function UILib:CreateButton(container, text, callback)
    local id = "button_" .. (#container.items + 1)
    local cont = Drawing.new("Square")
    cont.Filled = true
    cont.Corner = 5
    cont.ZIndex = Z_CONTROLS + 10

    local label = Drawing.new("Text")
    label.Color = COLOR_TEXT
    label.ZIndex = Z_CONTROLS + 11

    local arrow1 = Drawing.new("Line")
    arrow1.Color = COLOR_TEXT
    arrow1.Thickness = 2
    arrow1.ZIndex = Z_CONTROLS + 12

    local arrow2 = Drawing.new("Line")
    arrow2.Color = COLOR_TEXT
    arrow2.Thickness = 2
    arrow2.ZIndex = Z_CONTROLS + 12

    local element = {
        type = "button",
        id = id,
        container = cont,
        label = label,
        arrowLine1 = arrow1,
        arrowLine2 = arrow2,
        callback = callback,
        text = text,
        containerPos = Vector2.new(0,0),
        containerSize = Vector2.new(controlW, controlH),
        isHovered = false,
        wasPressed = false
    }
    hoverMap[id] = false
    table.insert(container.items, element)
    return element
end

-- CreateToggle
function UILib:CreateToggle(container, text, currentValue, callback)
    local containerDraw = Drawing.new("Square"); containerDraw.Filled = true; containerDraw.Corner = 5; containerDraw.ZIndex = Z_CONTROLS
    local box = Drawing.new("Square"); box.Filled = true; box.Corner = 3; box.ZIndex = Z_CONTROLS + 1
    local fill = Drawing.new("Square"); fill.Filled = true; fill.Corner = 2; fill.ZIndex = Z_CONTROLS + 2
    local label = Drawing.new("Text"); label.Color = COLOR_TEXT; label.ZIndex = Z_CONTROLS + 1

    local element = {
        type = "toggle",
        container = containerDraw,
        box = box,
        fill = fill,
        label = label,
        state = currentValue and true or false,
        callback = callback,
        text = text,
        containerPos = Vector2.new(0,0),
        containerSize = Vector2.new(controlW, controlH),
        checkboxPos = Vector2.new(0,0),
        checkboxSize = Vector2.new(checkboxSize, checkboxSize)
    }
    table.insert(container.items, element)
    return element
end

-- CreateSlider
function UILib:CreateSlider(container, text, minv, maxv, currentValue, step, callback)
    local indicator = Drawing.new("Square")
    indicator.Size = Vector2.new(10, 16); indicator.Filled = true; indicator.Color = COLOR_ACCENT; indicator.Visible = false; indicator.Corner = 3; indicator.ZIndex = Z_CONTROLS + 3
    local cont = Drawing.new("Square"); cont.Filled = true; cont.Corner = 5; cont.ZIndex = Z_CONTROLS
    local bar = Drawing.new("Square"); bar.Filled = true; bar.Corner = 3; bar.ZIndex = Z_CONTROLS + 1
    local fill = Drawing.new("Square"); fill.Filled = true; fill.Corner = 3; fill.ZIndex = Z_CONTROLS + 2
    local label = Drawing.new("Text"); label.Color = COLOR_TEXT; label.ZIndex = Z_CONTROLS + 1
    local valueLabel = Drawing.new("Text"); valueLabel.Color = COLOR_TEXT; valueLabel.ZIndex = Z_CONTROLS + 1

    local element = {
        type = "slider",
        container = cont,
        bar = bar,
        fill = fill,
        label = label,
        valueLabel = valueLabel,
        indicator = indicator,
        min = minv,
        max = maxv,
        value = currentValue or minv,
        step = step or 1,
        callback = callback,
        text = text,
        containerPos = Vector2.new(0,0),
        containerSize = Vector2.new(controlW, controlH),
        sliderPos = Vector2.new(0,0),
        sliderSize = Vector2.new(sliderW, 10)
    }
    table.insert(container.items, element)
    return element
end

-- CreateDropdown
function UILib:CreateDropdown(container, text, options, currentOption, callback, multipleOptions)
    local id = "dropdown_" .. (#container.items + 1)
    local cont = Drawing.new("Square"); cont.Filled = true; cont.Color = COLOR_PANEL; cont.Corner = 5; cont.ZIndex = Z_CONTROLS
    local label = Drawing.new("Text"); label.Text = text; label.Color = COLOR_TEXT; label.ZIndex = Z_CONTROLS + 1
    local previewBox = Drawing.new("Square"); previewBox.Filled = true; previewBox.Color = COLOR_PANEL2; previewBox.Corner = 5; previewBox.ZIndex = Z_CONTROLS + 2
    local selectionText = Drawing.new("Text"); selectionText.Color = COLOR_TEXT; selectionText.ZIndex = Z_CONTROLS + 3
    local dropdownContainer = Drawing.new("Square"); dropdownContainer.Filled = true; dropdownContainer.Color = COLOR_PANEL; dropdownContainer.Corner = 5; dropdownContainer.Visible = false; dropdownContainer.ZIndex = Z_DROPDOWN_BASE

    local opts = {}
    for i,opt in ipairs(options or {}) do
        local bg = Drawing.new("Square"); bg.Filled = true; bg.Color = COLOR_PANEL2; bg.Corner = 5; bg.Visible = false; bg.ZIndex = Z_DROPDOWN_OPTIONS + i*2
        local txt = Drawing.new("Text"); txt.Text = tostring(opt); txt.Color = COLOR_TEXT; txt.Visible = false; txt.ZIndex = Z_DROPDOWN_OPTIONS + i*2 + 1
        table.insert(opts, {background = bg, label = txt, text = opt, isHovered = false, selected = false})
    end

    local element = {
        type = "dropdown",
        id = id,
        container = cont,
        label = label,
        previewBox = previewBox,
        selectionText = selectionText,
        dropdownContainer = dropdownContainer,
        options = opts,
        callback = callback,
        currentOption = currentOption or (options and options[1]),
        selectedOptions = {},
        isOpen = false,
        text = text,
        containerPos = Vector2.new(0,0),
        containerSize = Vector2.new(controlW, controlH),
        previewBoxSize = 120,
        dropdownWidth = 200,
        dropdownHeight = 200,
        optionHeight = 30,
        titleBg = nil,
        titleText = nil,
        multipleOptions = multipleOptions or false
    }

    if element.multipleOptions and type(currentOption) == "table" then
        for _,v in ipairs(currentOption) do
            element.selectedOptions[v] = true
        end
    end

    element.titleBg = Drawing.new("Square") element.titleBg.Filled = true element.titleBg.Color = COLOR_PANEL element.titleBg.Corner = 5 element.titleBg.ZIndex = Z_DROPDOWN_OPTIONS element.titleBg.Visible = false
    element.titleText = Drawing.new("Text") element.titleText.Color = COLOR_TEXT element.titleText.ZIndex = Z_DROPDOWN_OPTIONS + 1 element.titleText.Visible = false

    function element:UpdateDropdown(mousePos, shouldRender)
        if not shouldRender then
            self.dropdownContainer.Visible = false
            if self.titleBg then self.titleBg.Visible = false end
            if self.titleText then self.titleText.Visible = false end
            for _,o in ipairs(self.options) do
                o.background.Visible = false
                o.label.Visible = false
            end
            return
        end

        self.container.Position = self.containerPos
        self.container.Size = self.containerSize
        self.container.Visible = true
        self.container.Color = COLOR_PANEL

        self.label.Position = Vector2.new(self.containerPos.x + 15, self.containerPos.y + self.containerSize.y/2 - 7)
        self.label.Visible = true

        local bx = self.containerPos.x + self.containerSize.x - self.previewBoxSize - 15
        local by = self.containerPos.y + (self.containerSize.y - 24)/2
        self.previewBox.Position = Vector2.new(bx, by)
        self.previewBox.Size = Vector2.new(self.previewBoxSize, 24)
        self.previewBox.Visible = true

        if self.multipleOptions then
            local cnt = 0
            self.selectedOptions = self.selectedOptions or {}
            for k,v in pairs(self.selectedOptions) do
                if v then cnt = cnt + 1 end
            end
            self.selectionText.Text = cnt > 0 and (cnt .. " selected") or "None"
        else
            self.selectionText.Text = self.currentOption
        end

        self.selectionText.Position = Vector2.new(bx + 10, by + 4)
        self.selectionText.Visible = true

        if self.isOpen then
            local bn = self.containerPos.x + self.containerSize.x + 10
            local bo = self.containerPos.y
            self.titleBg.Position = Vector2.new(bn, bo)
            self.titleBg.Size = Vector2.new(self.dropdownWidth, 35)
            self.titleBg.Visible = true
            self.titleText.Text = self.text
            self.titleText.Position = Vector2.new(bn + 10, bo + 10)
            self.titleText.Visible = true

            self.dropdownContainer.Position = Vector2.new(bn, bo)
            self.dropdownContainer.Size = Vector2.new(self.dropdownWidth, #self.options * self.optionHeight + 35)
            self.dropdownContainer.Visible = true

            for i, opt in ipairs(self.options) do
                local bp = bo + 35 + (i - 1) * self.optionHeight
                local bq = bn + 5
                opt.currentPos = Vector2.new(bq, bp)
                opt.currentSize = Vector2.new(self.dropdownWidth - 10, self.optionHeight - 5)
                opt.background.Position = opt.currentPos
                opt.background.Size = opt.currentSize
                opt.background.Visible = true
                opt.label.Position = Vector2.new(bn + 15, bp + 7)
                opt.label.Visible = true

                local br = mousePos.x >= opt.currentPos.x and mousePos.x <= opt.currentPos.x + opt.currentSize.x and mousePos.y >= opt.currentPos.y and mousePos.y <= opt.currentPos.y + opt.currentSize.y

                if self.multipleOptions then
                    opt.background.Color = self.selectedOptions[opt.text] and COLOR_ACCENT or (br and COLOR_HOVER or COLOR_PANEL2)
                else
                    opt.background.Color = opt.text == self.currentOption and COLOR_ACCENT or (br and COLOR_HOVER or COLOR_PANEL2)
                end

                opt.isHovered = br
                if br and mouseClick then
                    if self.multipleOptions then
                        self.selectedOptions[opt.text] = not self.selectedOptions[opt.text]
                        if self.callback then
                            local sel = {}
                            for k,v in pairs(self.selectedOptions) do if v then table.insert(sel,k) end end
                            self.callback(sel)
                        end
                    else
                        self.currentOption = opt.text
                        if self.callback then
                            self.callback({opt.text})
                        end
                    end
                end
            end
        end
    end

    hoverMap[id] = false
    table.insert(container.items, element)
    return element
end

-- CreateTextbox
function UILib:CreateTextbox(container, text, defaultValue, placeholder, clearOnFocus, callback)
    local id = "textbox_" .. (#container.items + 1)
    local cont = Drawing.new("Square"); cont.Filled = true; cont.Corner = 5; cont.ZIndex = 9000; cont.Color = COLOR_PANEL; cont.Position = Vector2.new(0,0); cont.Size = Vector2.new(controlW, controlH)
    local label = Drawing.new("Text"); label.Color = COLOR_TEXT; label.ZIndex = 9000; label.Position = Vector2.new(0,0); label.Text = text
    local inputBox = Drawing.new("Square"); inputBox.Filled = true; inputBox.Color = COLOR_PANEL2; inputBox.Corner = 5; inputBox.ZIndex = 9000; inputBox.Position = Vector2.new(0,0); inputBox.Size = Vector2.new(120, 24)
    local inputText = Drawing.new("Text"); inputText.Color = COLOR_TEXT; inputText.ZIndex = 9001; inputText.Position = Vector2.new(0,0); inputText.Text = defaultValue or ""

    local element = {
        type = "textbox",
        id = id,
        container = cont,
        label = label,
        inputBox = inputBox,
        inputText = inputText,
        text = text,
        value = defaultValue or "",
        placeholder = placeholder or "Type here...",
        clearOnFocus = clearOnFocus or false,
        callback = callback,
        isFocused = false,
        containerPos = Vector2.new(0,0),
        containerSize = Vector2.new(controlW, controlH),
        inputBoxWidth = 120
    }

    hoverMap[id] = false
    table.insert(container.items, element)
    return element
end

-- CreateColorPicker
function UILib:CreateColorPicker(container, text, defaultColor, callback)
    local id = "colorpicker_" .. (#container.items + 1)
    defaultColor = defaultColor or Color3.fromRGB(255,255,255)
    local h,s,v = rgbToHsv(defaultColor.R*255, defaultColor.G*255, defaultColor.B*255)

    local cont = Drawing.new("Square"); cont.Filled = true; cont.Color = COLOR_PANEL; cont.Corner = 5; cont.ZIndex = Z_CONTROLS; cont.Position = Vector2.new(0,0); cont.Size = Vector2.new(controlW, controlH)
    local label = Drawing.new("Text"); label.Text = text; label.Color = COLOR_TEXT; label.ZIndex = Z_CONTROLS + 1; label.Position = Vector2.new(0,0)
    local previewBox = Drawing.new("Square"); previewBox.Filled = true; previewBox.Color = defaultColor; previewBox.Corner = 5; previewBox.ZIndex = Z_CONTROLS + 2; previewBox.Position = Vector2.new(0,0); previewBox.Size = Vector2.new(24,24)

    local pickerContainer = Drawing.new("Square"); pickerContainer.Filled = true; pickerContainer.Color = COLOR_PANEL; pickerContainer.Corner = 5; pickerContainer.Visible = false; pickerContainer.ZIndex = Z_COLOR_PICKER
    local selectedPreview = Drawing.new("Square"); selectedPreview.Filled = true; selectedPreview.Color = defaultColor; selectedPreview.Visible = false; selectedPreview.ZIndex = Z_COLOR_PICKER + 1
    local hueGradient = Drawing.new("Square"); hueGradient.Filled = true; hueGradient.Color = Color3.fromRGB(255,0,0); hueGradient.Visible = false; hueGradient.ZIndex = Z_COLOR_PICKER + 1
    local satGradient = Drawing.new("Square"); satGradient.Filled = true; satGradient.Color = Color3.fromRGB(255,0,0); satGradient.Visible = false; satGradient.ZIndex = Z_COLOR_PICKER + 1
    local valGradient = Drawing.new("Square"); valGradient.Filled = true; valGradient.Color = Color3.fromRGB(255,0,0); valGradient.Visible = false; valGradient.ZIndex = Z_COLOR_PICKER + 1

    local element = {
        type = "colorpicker",
        id = id,
        container = cont,
        label = label,
        previewBox = previewBox,
        pickerContainer = pickerContainer,
        selectedColorPreview = selectedPreview,
        hueGradient = hueGradient,
        saturationGradient = satGradient,
        valueGradient = valGradient,
        callback = callback,
        currentColor = defaultColor,
        isOpen = false,
        text = text,
        containerPos = Vector2.new(0,0),
        containerSize = Vector2.new(controlW, controlH),
        previewBoxSize = 24,
        pickerWidth = 200,
        pickerHeight = 250,
        pickerPos = Vector2.new(0,0),
        hue = h or 0,
        saturation = s or 1,
        value = v or 1,
        titleBg = nil,
        titleText = nil,
        hueSegments = {},
        saturationSegments = {},
        valueSegments = {}
    }

    element.titleBg = Drawing.new("Square"); element.titleBg.Filled = true; element.titleBg.Color = COLOR_PANEL; element.titleBg.Corner = 5; element.titleBg.ZIndex = Z_COLOR_PICKER; element.titleBg.Visible = false
    element.titleText = Drawing.new("Text"); element.titleText.Color = COLOR_TEXT; element.titleText.ZIndex = Z_COLOR_PICKER + 1; element.titleText.Visible = false

    function element:UpdateColor()
        local rr, gg, bb = hsvToRgb(self.hue, self.saturation, self.value)
        self.currentColor = Color3.fromRGB(rr, gg, bb)
        if self.previewBox then self.previewBox.Color = self.currentColor end
        if self.selectedColorPreview then self.selectedColorPreview.Color = self.currentColor end
        if self.callback then self.callback(self.currentColor) end
    end

    function element:UpdateColorPicker(mousePos, shouldRender)
        if not shouldRender or not self.isOpen then
            self.pickerContainer.Visible = false
            self.selectedColorPreview.Visible = false
            self.hueGradient.Visible = false
            self.saturationGradient.Visible = false
            self.valueGradient.Visible = false
            if self.titleBg then self.titleBg.Visible = false end
            if self.titleText then self.titleText.Visible = false end
            for _,seg in ipairs(self.hueSegments) do seg.Visible = false end
            for _,seg in ipairs(self.saturationSegments) do seg.Visible = false end
            for _,seg in ipairs(self.valueSegments) do seg.Visible = false end
            return
        end

        self.container.Position = self.containerPos
        self.container.Size = self.containerSize
        self.container.Visible = true
        self.container.Color = COLOR_PANEL
        self.label.Position = Vector2.new(self.containerPos.x + 15, self.containerPos.y + self.containerSize.y/2 - 7)
        self.label.Visible = true

        local bx = self.containerPos.x + self.containerSize.x - self.previewBoxSize - 15
        local by = self.containerPos.y + (self.containerSize.y - self.previewBoxSize)/2
        self.previewPos = Vector2.new(bx, by)
        self.previewBox.Position = self.previewPos
        self.previewBox.Size = Vector2.new(self.previewBoxSize, self.previewBoxSize)
        self.previewBox.Visible = true

        if self.isOpen then
            local bn = self.containerPos.x + self.containerSize.x + 10
            local bo = self.containerPos.y
            self.pickerPos = Vector2.new(bn, bo)
            self.pickerContainer.Position = self.pickerPos
            self.pickerContainer.Size = Vector2.new(self.pickerWidth, self.pickerHeight)
            self.pickerContainer.Visible = true

            self.titleBg.Position = Vector2.new(bn, bo)
            self.titleBg.Size = Vector2.new(self.pickerWidth, 35)
            self.titleBg.Visible = true
            self.titleText.Text = self.text
            self.titleText.Position = Vector2.new(bn + 10, bo + 10)
            self.titleText.Visible = true

            self.selectedPreviewPos = Vector2.new(bn + 10, bo + 45)
            self.selectedPreviewSize = Vector2.new(self.pickerWidth - 20, 40)
            self.selectedColorPreview.Position = self.selectedPreviewPos
            self.selectedColorPreview.Size = self.selectedPreviewSize
            self.selectedColorPreview.Visible = true

            self.huePos = Vector2.new(bn + 10, bo + 95)
            self.hueSize = Vector2.new(self.pickerWidth - 20, 25)
            self.hueGradient.Position = self.huePos
            self.hueGradient.Size = self.hueSize
            self.hueGradient.Visible = true

            self.saturationPos = Vector2.new(bn + 10, bo + 130)
            self.saturationSize = Vector2.new(self.pickerWidth - 20, 25)
            self.saturationGradient.Position = self.saturationPos
            self.saturationGradient.Size = self.saturationSize
            self.saturationGradient.Visible = true

            self.valuePos = Vector2.new(bn + 10, bo + 165)
            self.valueSize = Vector2.new(self.pickerWidth - 20, 25)
            self.valueGradient.Position = self.valuePos
            self.valueGradient.Size = self.valueSize
            self.valueGradient.Visible = true

            local segments = 36
            local segW = self.hueSize.x / segments
            for Q = 0, segments - 1 do
                if not self.hueSegments[Q+1] then
                    self.hueSegments[Q+1] = Drawing.new("Square")
                    self.hueSegments[Q+1].Filled = true
                    self.hueSegments[Q+1].ZIndex = self.hueGradient.ZIndex
                    self.hueSegments[Q+1].Corner = 0
                end
                local seg = self.hueSegments[Q+1]
                local hv = Q / segments
                local rr,gg,bb = hsvToRgb(hv, 1, 1)
                seg.Position = Vector2.new(self.huePos.x + Q*segW, self.huePos.y)
                seg.Size = Vector2.new(segW + 0.5, self.hueSize.y)
                seg.Color = Color3.fromRGB(rr,gg,bb)
                seg.Visible = true
            end

            local rr,gg,bb = hsvToRgb(self.hue, 1, self.value)
            for Q = 0, segments - 1 do
                if not self.saturationSegments[Q+1] then
                    self.saturationSegments[Q+1] = Drawing.new("Square")
                    self.saturationSegments[Q+1].Filled = true
                    self.saturationSegments[Q+1].ZIndex = self.saturationGradient.ZIndex
                    self.saturationSegments[Q+1].Corner = 0
                end
                local seg = self.saturationSegments[Q+1]
                local t = Q / segments
                local rcol = rr * t + (1-t)
                local gcol = gg * t + (1-t)
                local bcol = bb * t + (1-t)
                seg.Position = Vector2.new(self.saturationPos.x + Q*segW, self.saturationPos.y)
                seg.Size = Vector2.new(segW + 0.5, self.saturationSize.y)
                seg.Color = Color3.fromRGB(math.floor(rcol*255), math.floor(gcol*255), math.floor(bcol*255))
                seg.Visible = true
            end

            local rr2,gg2,bb2 = hsvToRgb(self.hue, self.saturation, 1)
            for Q = 0, segments - 1 do
                if not self.valueSegments[Q+1] then
                    self.valueSegments[Q+1] = Drawing.new("Square")
                    self.valueSegments[Q+1].Filled = true
                    self.valueSegments[Q+1].ZIndex = self.valueGradient.ZIndex
                    self.valueSegments[Q+1].Corner = 0
                end
                local seg = self.valueSegments[Q+1]
                local d = Q / segments
                seg.Position = Vector2.new(self.valuePos.x + Q*segW, self.valuePos.y)
                seg.Size = Vector2.new(segW + 0.5, self.valueSize.y)
                seg.Color = Color3.fromRGB(math.floor(rr2 * 255 * d), math.floor(gg2 * 255 * d), math.floor(bb2 * 255 * d))
                seg.Visible = true
            end

            local inHue = mousePos.x >= self.huePos.x and mousePos.x <= self.huePos.x + self.hueSize.x and mousePos.y >= self.huePos.y and mousePos.y <= self.huePos.y + self.hueSize.y
            if inHue and mouseHold then
                local hv = (mousePos.x - self.huePos.x) / self.hueSize.x
                self.hue = clamp(hv, 0, 1)
                self:UpdateColor()
            end

            local inSat = mousePos.x >= self.saturationPos.x and mousePos.x <= self.saturationPos.x + self.saturationSize.x and mousePos.y >= self.saturationPos.y and mousePos.y <= self.saturationPos.y + self.saturationSize.y
            if inSat and mouseHold then
                local sv = (mousePos.x - self.saturationPos.x) / self.saturationSize.x
                self.saturation = clamp(sv, 0, 1)
                self:UpdateColor()
            end

            local inVal = mousePos.x >= self.valuePos.x and mousePos.x <= self.valuePos.x + self.valueSize.x and mousePos.y >= self.valuePos.y and mousePos.y <= self.valuePos.y + self.valueSize.y
            if inVal and mouseHold then
                local vv = (mousePos.x - self.valuePos.x) / self.valueSize.x
                self.value = clamp(vv, 0, 1)
                self:UpdateColor()
            end
        end
    end

    function element:Destroy()
        if self.container then self.container:Remove() end
        if self.label then self.label:Remove() end
        if self.previewBox then self.previewBox:Remove() end
        if self.pickerContainer then self.pickerContainer:Remove() end
        if self.selectedColorPreview then self.selectedColorPreview:Remove() end
        if self.hueGradient then self.hueGradient:Remove() end
        if self.saturationGradient then self.saturationGradient:Remove() end
        if self.valueGradient then self.valueGradient:Remove() end
        if self.titleBg then self.titleBg:Remove() end
        if self.titleText then self.titleText:Remove() end
        for _,seg in ipairs(self.hueSegments) do seg:Remove() end
        for _,seg in ipairs(self.saturationSegments) do seg:Remove() end
        for _,seg in ipairs(self.valueSegments) do seg:Remove() end
    end

    element.label.Text = text
    element:UpdateColor()
    hoverMap[id] = false
    table.insert(container.items, element)
    return element
end

-- Helper: Close all dropdowns and color pickers
function UILib:CloseAllDropdownsAndColorPickers()
    for _,tab in ipairs(self.tabs) do
        for _,item in ipairs(tab.items) do
            if item.type == "dropdown" or item.type == "colorpicker" then
                item.isOpen = false
                if item.dropdownContainer then item.dropdownContainer.Visible = false end
                if item.titleBg then item.titleBg.Visible = false end
                if item.titleText then item.titleText.Visible = false end
                if item.pickerContainer then item.pickerContainer.Visible = false end
                if item.selectedColorPreview then item.selectedColorPreview.Visible = false end
                if item.hueGradient then item.hueGradient.Visible = false end
                if item.saturationGradient then item.saturationGradient.Visible = false end
                if item.valueGradient then item.valueGradient.Visible = false end
                if item.hueSegments then for _,s in ipairs(item.hueSegments) do s.Visible = false end end
                if item.saturationSegments then for _,s in ipairs(item.saturationSegments) do s.Visible = false end end
                if item.valueSegments then for _,s in ipairs(item.valueSegments) do s.Visible = false end end
                if item.options then for _,o in ipairs(item.options) do o.background.Visible = false; o.label.Visible = false end end
            end
        end
    end
end

-- Notifications
function UILib:Notify(params)
    local width = 250
    local height = 80
    local pad = 10
    local top = 70
    local offset = top
    for _,n in ipairs(self.notifications) do
        offset = offset + height + pad
    end

    local container = Drawing.new("Square")
    container.Size = Vector2.new(width, height)
    container.Position = Vector2.new(20, top)
    container.Filled = true
    container.Color = COLOR_BG
    container.Visible = true
    container.Corner = 7
    container.ZIndex = 50

    local title = Drawing.new("Text")
    title.Text = params.Title or "Notification"
    title.Position = Vector2.new(20 + 10, top + 10)
    title.Color = COLOR_ACCENT
    title.Visible = true
    title.ZIndex = 51

    local content = Drawing.new("Text")
    content.Text = params.Content or ""
    content.Position = Vector2.new(20 + 10, top + 30)
    content.Color = COLOR_TEXT
    content.Visible = true
    content.ZIndex = 51

    local progressBg = Drawing.new("Square")
    progressBg.Size = Vector2.new(width, 5)
    progressBg.Position = Vector2.new(20, top + height - 10)
    progressBg.Filled = true
    progressBg.Color = COLOR_PANEL2
    progressBg.Visible = true
    progressBg.Corner = 5
    progressBg.ZIndex = 51

    local progressFill = Drawing.new("Square")
    progressFill.Size = Vector2.new(width, 5)
    progressFill.Position = Vector2.new(20, top + height - 10)
    progressFill.Filled = true
    progressFill.Color = COLOR_ACCENT
    progressFill.Visible = true
    progressFill.Corner = 5
    progressFill.ZIndex = 52

    local notif = {
        container = container,
        title = title,
        content = content,
        progressBg = progressBg,
        progressFill = progressFill,
        startTime = os.clock(),
        duration = params.Duration or 5,
        fadeStart = (params.Duration or 5) - 0.5,
        targetY = offset
    }

    table.insert(self.notifications, 1, notif)
end

function UILib:UpdateNotifications()
    local top = 70
    local pad = 10
    local height = 80
    local idx = 1
    while idx <= #self.notifications do
        local n = self.notifications[idx]
        if n and n.container then
            local elapsed = os.clock() - n.startTime
            local target = top + (idx-1) * (height + pad)
            n.container.Position = Vector2.new(n.container.Position.x, n.targetY or target)
            n.title.Position = Vector2.new(n.title.Position.x, n.targetY + 10)
            n.content.Position = Vector2.new(n.content.Position.x, n.targetY + 30)
            n.progressBg.Position = Vector2.new(n.progressBg.Position.x, n.targetY + height - 10)
            n.progressFill.Position = Vector2.new(n.progressFill.Position.x, n.targetY + height - 10)

            if elapsed >= n.duration then
                n.container.Visible = false
                n.title.Visible = false
                n.content.Visible = false
                n.progressBg.Visible = false
                n.progressFill.Visible = false
                table.remove(self.notifications, idx)
            else
                local prog = clamp(1 - (elapsed / n.duration), 0, 1)
                local fillW = prog * n.progressBg.Size.x
                n.progressFill.Size = Vector2.new(fillW, n.progressFill.Size.y)
                if elapsed >= n.fadeStart then
                    local f = 1 - (elapsed - n.fadeStart) / (n.duration - n.fadeStart)
                    if n.container then n.container.Transparency = f end
                    if n.title then n.title.Transparency = f end
                    if n.content then n.content.Transparency = f end
                    if n.progressBg then n.progressBg.Transparency = f end
                    if n.progressFill then n.progressFill.Transparency = f end
                end
                idx = idx + 1
            end
        else
            idx = idx + 1
        end
    end
end

-- Step: must be called each tick from your script
function UILib:Step()
    local mousePos = getMousePos()
    mouseDownLast = mouseDown
    mouseDown = ismouse1pressed()
    mouseClick = false
    mouseHold = false
    if mouseDown and not mouseDownLast then
        mouseClick = true
        mouseHold = true
    elseif mouseDown and mouseDownLast then
        mouseHold = true
    else
        mouseHold = false
    end

    -- toggle UI with key
    if self.toggleKey then
        local code = KEYMAP[self.toggleKey:upper()]
        if code and keyDownEdge(code) and isrbxactive() then
            VISIBLE = not VISIBLE
            self:CloseAllDropdownsAndColorPickers()
            self.base.Visible = VISIBLE
            self.title.Visible = VISIBLE
            self.closeLine1.Visible = VISIBLE
            self.closeLine2.Visible = VISIBLE
            self.minimizeLine.Visible = VISIBLE
            self.closeBox.Visible = false
            self.minimizeBox.Visible = false
            for _,tab in ipairs(self.tabs) do
                tab.tab.Visible = VISIBLE and not self.minimized
                tab.label.Visible = VISIBLE and not self.minimized
                tab.indicator.Visible = VISIBLE and not self.minimized and tab == self.activeTab
                for _,item in ipairs(tab.items) do
                    local show = VISIBLE and not self.minimized and tab == self.activeTab
                    if item.container then item.container.Visible = show end
                    if item.label then item.label.Visible = show end
                    if item.box then item.box.Visible = show end
                    if item.fill then item.fill.Visible = show and item.state end
                    if item.bar then item.bar.Visible = show end
                    if item.indicator then item.indicator.Visible = show end
                    if item.valueLabel then item.valueLabel.Visible = show end
                    if item.previewBox then item.previewBox.Visible = show end
                    if item.selectionText then item.selectionText.Visible = show end
                    if item.inputBox then item.inputBox.Visible = show end
                    if item.inputText then item.inputText.Visible = show end
                    if item.cursor then item.cursor.Visible = false end
                    if item.type == "dropdown" or item.type == "colorpicker" then
                        item.isOpen = false
                    end
                end
            end
        end
    end

    if not VISIBLE then
        return
    end

    -- Update notifications
    self:UpdateNotifications()

    -- Close/minimize hitboxes
    local overClose = UILib._IsMouseWithinBounds(Vector2.new(winX + winW - 30, winY + 5), Vector2.new(25,25))
    self.closeBox.Visible = overClose
    if overClose and mouseClick then
        self:Destroy()
        return
    end

    local overMin = UILib._IsMouseWithinBounds(Vector2.new(winX + winW - 60, winY + 5), Vector2.new(25,25))
    self.minimizeBox.Visible = overMin
    if overMin and mouseClick then
        self.minimized = not self.minimized
        for _,tab in ipairs(self.tabs) do
            for _,item in ipairs(tab.items) do
                if item.type == "colorpicker" then
                    item.isOpen = false
                    if item.pickerContainer then item.pickerContainer.Visible = false end
                    if item.selectedColorPreview then item.selectedColorPreview.Visible = false end
                    if item.hueGradient then item.hueGradient.Visible = false end
                    if item.valueGradient then item.valueGradient.Visible = false end
                    if item.titleBg then item.titleBg.Visible = false end
                    if item.titleText then item.titleText.Visible = false end
                    if item.hueSegments then for _,s in ipairs(item.hueSegments) do s.Visible = false end end
                    if item.valueSegments then for _,s in ipairs(item.valueSegments) do s.Visible = false end end
                end
            end
        end
        self.base.Size = Vector2.new(winW, self.minimized and 35 or winH)
        for _,tab in ipairs(self.tabs) do
            tab.tab.Visible = not self.minimized
            tab.label.Visible = not self.minimized
            tab.indicator.Visible = not self.minimized and tab == self.activeTab
            for _,item in ipairs(tab.items) do
                if item.container then item.container.Visible = not self.minimized and tab == self.activeTab end
                if item.label then item.label.Visible = not self.minimized and tab == self.activeTab end
                if item.box then item.box.Visible = not self.minimized and tab == self.activeTab end
                if item.fill then item.fill.Visible = not self.minimized and tab == self.activeTab and item.state end
                if item.bar then item.bar.Visible = not self.minimized and tab == self.activeTab end
                if item.indicator then item.indicator.Visible = not self.minimized and tab == self.activeTab end
                if item.valueLabel then item.valueLabel.Visible = not self.minimized and tab == self.activeTab end
            end
        end
    end

    -- Dragging the window
    if mouseClick and UILib._IsMouseWithinBounds(Vector2.new(winX, winY), Vector2.new(winW - 65, 30)) and not dragging then
        dragging = true
        dragOffset = Vector2.new(mousePos.x - winX, mousePos.y - winY)
    elseif not ismouse1pressed() then
        dragging = false
    end

    if dragging then
        winX = mousePos.x - dragOffset.x
        winY = mousePos.y - dragOffset.y
        self.base.Position = Vector2.new(winX, winY)
        self.title.Position = Vector2.new(winX + 10, winY + 10)
        self.closeBox.Position = Vector2.new(winX + winW - 30, winY + 5)
        self.closeLine1.From = Vector2.new(winX + winW - 25, winY + 10); self.closeLine1.To = Vector2.new(winX + winW - 10, winY + 25)
        self.closeLine2.From = Vector2.new(winX + winW - 25, winY + 25); self.closeLine2.To = Vector2.new(winX + winW - 10, winY + 10)
        self.minimizeBox.Position = Vector2.new(winX + winW - 60, winY + 5)
        self.minimizeLine.From = Vector2.new(winX + winW - 55, winY + 17); self.minimizeLine.To = Vector2.new(winX + winW - 40, winY + 17)
        for _,tab in ipairs(self.tabs) do
            local ty = winY + 50 + (tab.index - 1) * (tabH + spacing)
            tab.tab.Position = Vector2.new(winX + 10, ty)
            tab.label.Position = Vector2.new(winX + 20, ty + 8)
            tab.indicator.Position = Vector2.new(winX + 10, ty + 5)
            tab.pos = Vector2.new(winX + 10, ty)
            tab.tab.Visible = not self.minimized
            tab.label.Visible = not self.minimized
            tab.indicator.Visible = not self.minimized and tab == self.activeTab
        end
    end

    -- Tab clicking
    if mouseClick and not dragging and not self.minimized then
        for _,tab in ipairs(self.tabs) do
            if UILib._IsMouseWithinBounds(tab.pos, tab.size) then
                -- click on a tab -> activate
                self.activeTab = tab
                for _,t in ipairs(self.tabs) do
                    t.indicator.Visible = not self.minimized and t == tab
                end
            end
        end
    end

    -- Update hover state of tabs
    for _,tab in ipairs(self.tabs) do
        local hovered = not self.minimized and UILib._IsMouseWithinBounds(tab.pos, tab.size)
        if hovered and not tabHoverMap[tab.id] then tabHoverMap[tab.id] = true
        elseif not hovered and tabHoverMap[tab.id] then tabHoverMap[tab.id] = false end
        tab.indicator.Visible = not self.minimized and tab == self.activeTab
        tab.tab.Color = tabHoverMap[tab.id] and COLOR_PANEL2 or COLOR_PANEL
    end

    -- Update items for active tab
    for _,tab in ipairs(self.tabs) do
        local isActive = tab == self.activeTab and not self.minimized
        for idx,item in ipairs(tab.items) do
            local itemY = winY + 50 + (idx - 1) * (controlH + spacing)
            local itemX = winX + 130
            item.containerPos = Vector2.new(itemX, itemY)
            if item.container then
                item.container.Position = item.containerPos
                item.container.Size = item.containerSize
                item.container.Filled = true
                item.container.Visible = isActive
                item.container.Corner = 5
            end

            if item.type == "button" then
                item.label.Text = item.text
                item.label.Position = Vector2.new(itemX + 15, itemY + controlH/2 - 7)
                item.label.Color = COLOR_TEXT
                item.label.Visible = isActive

                local hover = UILib._IsMouseWithinBounds(item.containerPos, item.containerSize)
                if hover and not hoverMap[item.id] then hoverMap[item.id] = true
                elseif not hover and hoverMap[item.id] then hoverMap[item.id] = false end
                item.container.Color = hoverMap[item.id] and COLOR_PANEL2 or COLOR_PANEL

                local arrowX = itemX + controlW - 25
                local arrowY = itemY + controlH/2
                local c1 = 6
                item.arrowLine1.From = Vector2.new(arrowX, arrowY - c1)
                item.arrowLine1.To = Vector2.new(arrowX + c1, arrowY)
                item.arrowLine1.Visible = isActive
                item.arrowLine2.From = Vector2.new(arrowX, arrowY + c1)
                item.arrowLine2.To = Vector2.new(arrowX + c1, arrowY)
                item.arrowLine2.Visible = isActive

                if hover and mouseClick and isActive and item.callback then
                    item.callback()
                end

            elseif item.type == "toggle" then
                item.label.Text = item.text
                item.label.Position = Vector2.new(itemX + 15, itemY + controlH/2 - 7)
                item.label.Color = COLOR_TEXT
                item.label.Visible = isActive

                local cbX = itemX + controlW - item.checkboxSize.x - 15
                local cbY = itemY + controlH/2 - item.checkboxSize.y/2
                item.checkboxPos = Vector2.new(cbX, cbY)
                item.box.Position = item.checkboxPos
                item.box.Size = item.checkboxSize
                item.box.Filled = true
                item.box.Color = COLOR_PANEL2
                item.box.Corner = 3
                item.box.Visible = isActive

                item.fill.Position = Vector2.new(cbX + 3, cbY + 3)
                item.fill.Size = Vector2.new(item.checkboxSize.x - 6, item.checkboxSize.y - 6)
                item.fill.Filled = true
                item.fill.Color = COLOR_ACCENT
                item.fill.Corner = 2
                item.fill.Visible = isActive and item.state

                local overBox = UILib._IsMouseWithinBounds(item.checkboxPos, item.checkboxSize)
                if overBox and mouseClick and isActive then
                    item.state = not item.state
                    if item.callback then item.callback(item.state) end
                end
                if item.container then item.container.Color = COLOR_PANEL end

            elseif item.type == "slider" then
                item.label.Text = item.text
                item.label.Position = Vector2.new(itemX + 15, itemY + controlH/2 - 7)
                item.label.Color = COLOR_TEXT
                item.label.Visible = isActive

                local sliderX = itemX + controlW - item.sliderSize.x - 40
                local sliderY = itemY + controlH/2 - item.sliderSize.y/2
                item.sliderPos = Vector2.new(sliderX, sliderY)
                local ratio = 0
                if item.max ~= item.min then ratio = (item.value - item.min) / (item.max - item.min) end
                local fillWidth = item.sliderSize.x * ratio
                item.bar.Position = item.sliderPos
                item.bar.Size = item.sliderSize
                item.bar.Filled = true
                item.bar.Color = COLOR_PANEL2
                item.bar.Corner = 3
                item.bar.Visible = isActive

                item.fill.Position = item.sliderPos
                item.fill.Size = Vector2.new(fillWidth, item.sliderSize.y)
                item.fill.Filled = true
                item.fill.Color = COLOR_ACCENT
                item.fill.Corner = 3
                item.fill.Visible = isActive

                local indX = item.sliderPos.x + fillWidth - 5
                local indY = item.sliderPos.y - 3
                item.indicator.Position = Vector2.new(indX, indY)
                item.indicator.Visible = isActive

                item.valueLabel.Text = tostring(item.value)
                item.valueLabel.Position = Vector2.new(sliderX - 30, itemY + controlH/2 - 7)
                item.valueLabel.Color = COLOR_TEXT
                item.valueLabel.Visible = isActive

                item.container.Color = COLOR_PANEL

                local overSlider = UILib._IsMouseWithinBounds(item.sliderPos, item.sliderSize)
                if overSlider and mouseHold and isActive then
                    local rel = clamp(mousePos.x - item.sliderPos.x, 0, item.sliderSize.x)
                    local perc = rel / item.sliderSize.x
                    local rawVal = item.min + (item.max - item.min) * perc
                    local stepped = math.floor(rawVal / item.step + 0.5) * item.step
                    local finalVal = clamp(stepped, item.min, item.max)
                    item.value = finalVal
                    item.valueLabel.Text = tostring(finalVal)
                    if item.callback then item.callback(finalVal) end
                end

            elseif item.type == "dropdown" then
                local shouldRender = VISIBLE and not self.minimized and tab == self.activeTab
                item.container.Visible = shouldRender
                item.label.Visible = shouldRender
                item.previewBox.Visible = shouldRender
                item.selectionText.Visible = shouldRender
                if shouldRender then
                    local bx = item.containerPos.x + item.containerSize.x - item.previewBoxSize - 15
                    local by = item.containerPos.y + (item.containerSize.y - 24)/2
                    local clickPreview = mousePos.x >= bx and mousePos.x <= bx + item.previewBoxSize and mousePos.y >= by and mousePos.y <= by + 24
                    if clickPreview and mouseClick then
                        if not item.isOpen then
                            self:CloseAllDropdownsAndColorPickers()
                            item.isOpen = true
                        else
                            item.isOpen = false
                            if item.dropdownContainer then item.dropdownContainer.Visible = false end
                            if item.titleBg then item.titleBg.Visible = false end
                            if item.titleText then item.titleText.Visible = false end
                            for _, opt in ipairs(item.options) do
                                opt.background.Visible = false
                                opt.label.Visible = false
                            end
                        end
                    elseif mouseClick and item.pickerContainer and not (mousePos.x >= item.pickerPos.x and mousePos.x <= item.pickerPos.x + item.pickerWidth and mousePos.y >= item.pickerPos.y and mousePos.y <= item.pickerPos.y + item.pickerHeight) then
                        item.isOpen = false
                    end
                    item:UpdateDropdown(mousePos, shouldRender)
                else
                    item.isOpen = false
                    if item.dropdownContainer then item.dropdownContainer.Visible = false end
                    if item.titleBg then item.titleBg.Visible = false end
                    if item.titleText then item.titleText.Visible = false end
                    for _,opt in ipairs(item.options) do
                        opt.background.Visible = false
                        opt.label.Visible = false
                    end
                end

            elseif item.type == "textbox" then
                local shouldRender = VISIBLE and not self.minimized and tab == self.activeTab
                item.container.Visible = shouldRender
                item.label.Visible = shouldRender
                item.inputBox.Visible = shouldRender
                item.inputText.Visible = shouldRender
                if shouldRender then
                    item.label.Text = item.text
                    item.label.Position = Vector2.new(item.containerPos.x + 15, item.containerPos.y + item.containerSize.y/2 - 7)
                    item.inputBox.Size = Vector2.new(item.inputBoxWidth, 24)
                    local ibx = item.containerPos.x + item.containerSize.x - item.inputBoxWidth - 15
                    local iby = item.containerPos.y + item.containerSize.y/2 - 12
                    item.inputBox.Position = Vector2.new(ibx, iby)
                    item.inputBox.Color = item.isFocused and Color3.fromRGB(60,60,60) or COLOR_PANEL2
                    item.inputText.Text = (item.value == "" and item.placeholder) or item.value
                    item.inputText.Position = Vector2.new(ibx + 6, iby + 4)
                    item.inputText.Visible = true

                    -- focus click
                    local overInput = UILib._IsMouseWithinBounds(Vector2.new(ibx, iby), Vector2.new(item.inputBoxWidth, 24))
                    if overInput and mouseClick and shouldRender then
                        item.isFocused = true
                        if item.clearOnFocus then item.value = "" end
                    elseif mouseClick and not overInput then
                        item.isFocused = false
                    end

                    -- This library relies on executor key input functions; typical text input handling is limited in executors.
                    -- If your executor provides text input hooks, connect them to set item.value accordingly and call callback.
                else
                    item.isFocused = false
                end

            elseif item.type == "colorpicker" then
                local shouldRender = VISIBLE and not self.minimized and tab == self.activeTab
                if shouldRender then
                    local bx = item.containerPos.x + item.containerSize.x - item.previewBoxSize - 15
                    local by = item.containerPos.y + (item.containerSize.y - item.previewBoxSize)/2
                    local clickPreview = mousePos.x >= bx and mousePos.x <= bx + item.previewBoxSize and mousePos.y >= by and mousePos.y <= by + item.previewBoxSize
                    if clickPreview and mouseClick then
                        if not item.isOpen then
                            self:CloseAllDropdownsAndColorPickers()
                            item.isOpen = true
                        else
                            item.isOpen = false
                        end
                    elseif mouseClick and item.pickerContainer and not (mousePos.x >= item.pickerPos.x and mousePos.x <= item.pickerPos.x + item.pickerWidth and mousePos.y >= item.pickerPos.y and mousePos.y <= item.pickerPos.y + item.pickerHeight) then
                        item.isOpen = false
                    end
                    item:UpdateColorPicker(mousePos, shouldRender)
                else
                    item.isOpen = false
                    if item.pickerContainer then item.pickerContainer.Visible = false end
                    if item.selectedColorPreview then item.selectedColorPreview.Visible = false end
                    if item.hueGradient then item.hueGradient.Visible = false end
                    if item.saturationGradient then item.saturationGradient.Visible = false end
                    if item.valueGradient then item.valueGradient.Visible = false end
                    if item.titleBg then item.titleBg.Visible = false end
                    if item.titleText then item.titleText.Visible = false end
                    if item.hueSegments then for _,s in ipairs(item.hueSegments) do s.Visible = false end end
                    if item.saturationSegments then for _,s in ipairs(item.saturationSegments) do s.Visible = false end end
                    if item.valueSegments then for _,s in ipairs(item.valueSegments) do s.Visible = false end end
                end
            end
        end
    end
end

-- Destroy window (cleans drawings)
function UILib:Destroy()
    if self.base then self.base:Remove() end
    if self.title then self.title:Remove() end
    if self.closeBox then self.closeBox:Remove() end
    if self.closeLine1 then self.closeLine1:Remove() end
    if self.closeLine2 then self.closeLine2:Remove() end
    if self.minimizeBox then self.minimizeBox:Remove() end
    if self.minimizeLine then self.minimizeLine:Remove() end

    for _,tab in ipairs(self.tabs) do
        if tab.tab then tab.tab:Remove() end
        if tab.label then tab.label:Remove() end
        if tab.indicator then tab.indicator:Remove() end
        for _,item in ipairs(tab.items) do
            if item.container then item.container:Remove() end
            if item.type == "button" then
                if item.label then item.label:Remove() end
                if item.arrowLine1 then item.arrowLine1:Remove() end
                if item.arrowLine2 then item.arrowLine2:Remove() end
            elseif item.type == "toggle" then
                if item.box then item.box:Remove() end
                if item.fill then item.fill:Remove() end
                if item.label then item.label:Remove() end
            elseif item.type == "slider" then
                if item.bar then item.bar:Remove() end
                if item.fill then item.fill:Remove() end
                if item.label then item.label:Remove() end
                if item.valueLabel then item.valueLabel:Remove() end
                if item.indicator then item.indicator:Remove() end
            elseif item.type == "dropdown" then
                if item.container then item.container:Remove() end
                if item.label then item.label:Remove() end
                if item.previewBox then item.previewBox:Remove() end
                if item.selectionText then item.selectionText:Remove() end
                if item.dropdownContainer then item.dropdownContainer:Remove() end
                if item.titleBg then item.titleBg:Remove() end
                if item.titleText then item.titleText:Remove() end
                for _,opt in ipairs(item.options) do
                    if opt.background then opt.background:Remove() end
                    if opt.label then opt.label:Remove() end
                end
            elseif item.type == "textbox" then
                if item.container then item.container:Remove() end
                if item.label then item.label:Remove() end
                if item.inputBox then item.inputBox:Remove() end
                if item.inputText then item.inputText:Remove() end
            elseif item.type == "colorpicker" then
                if item.container then item.container:Remove() end
                if item.label then item.label:Remove() end
                if item.previewBox then item.previewBox:Remove() end
                if item.pickerContainer then item.pickerContainer:Remove() end
                if item.selectedColorPreview then item.selectedColorPreview:Remove() end
                if item.hueGradient then item.hueGradient:Remove() end
                if item.saturationGradient then item.saturationGradient:Remove() end
                if item.valueGradient then item.valueGradient:Remove() end
                if item.titleBg then item.titleBg:Remove() end
                if item.titleText then item.titleText:Remove() end
                if item.hueSegments then for _,s in ipairs(item.hueSegments) do s:Remove() end end
                if item.saturationSegments then for _,s in ipairs(item.saturationSegments) do s:Remove() end end
                if item.valueSegments then for _,s in ipairs(item.valueSegments) do s:Remove() end end
            end
        end
    end
    self.tabs = {}
    self.activeTab = nil
end

return UILib
