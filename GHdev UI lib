UILib = {}
UILib.__index = UILib
local a = game:GetService("Players").LocalPlayer
local b = a:GetMouse()
local function c(d, e, f)
    if d < e then
        return e
    elseif d > f then
        return f
    else
        return d
    end
end
local function g()
    return Vector2.new(b.X, b.Y)
end
function UILib._IsMouseWithinBounds(h, i)
    local j = g()
    return h and i and j.X >= h.x and j.x <= h.x + i.x and j.y >= h.y and j.y <= h.y + i.y
end
local k = true
local l, m = 200, 200
local n, o = 600, 350
local p, q = 100, 30
local r = 10
local s = 420
local t = 35
local u = 120
local v = 20
local w = 25
local x = Color3.fromRGB(20, 20, 20)
local y = Color3.fromRGB(106, 0, 255)
local z = Color3.fromRGB(30, 30, 30)
local A = Color3.fromRGB(255, 255, 255)
local B = Color3.fromRGB(40, 40, 40)
local C = Color3.fromRGB(40, 40, 40)
local D = Color3.fromRGB(50, 50, 50)
local E = false
local F = Vector2.new(0, 0)
local G = false
local H = false
local I = true
local J = {}
local K = {}
local L = {}
local M = {}
local N = {}
local function O(P, d)
    for Q, R in ipairs(P) do
        if R == d then
            return Q
        end
    end
    return nil
end
local S, T = 800, 600
local U = 1
local V = U + 10
local W = V + 10
local X = W + 10
local Y = 9000
local Z = 9500
local _ = 9900
local a0 = 9999
local a1 = 9000
local a2 = Color3.fromRGB(60, 60, 60)
local a3 = Color3.fromRGB(40, 40, 40)
local a4 = 0.5
local a5 = {}
local a6 = {}
local a7 = {
    A = 0x41,
    B = 0x42,
    C = 0x43,
    D = 0x44,
    E = 0x45,
    F = 0x46,
    G = 0x47,
    H = 0x48,
    I = 0x49,
    J = 0x4A,
    K = 0x4B,
    L = 0x4C,
    M = 0x4D,
    N = 0x4E,
    O = 0x4F,
    P = 0x50,
    Q = 0x51,
    R = 0x52,
    S = 0x53,
    T = 0x54,
    U = 0x55,
    V = 0x56,
    W = 0x57,
    X = 0x58,
    Y = 0x59,
    Z = 0x5A,
    M1 = 0x01,
    M2 = 0x02,
    ["1"] = 0x31,
    ["2"] = 0x32,
    ["3"] = 0x33,
    ["4"] = 0x34,
    ["5"] = 0x35,
    ["6"] = 0x36,
    ["7"] = 0x37,
    ["8"] = 0x38,
    ["9"] = 0x39,
    ["0"] = 0x30,
    SHIFT = 0x10,
    RSHIFT = 0xA1,
    CONTROL = 0x11,
    RCONTROL = 0xA3,
    BACKSPACE = 0x08,
    SPACE = 0x20,
    ENTER = 0x0D,
    TAB = 0x09,
    ESCAPE = 0x1B
}
local function a8(a9)
    for aa, ab in pairs(a7) do
        if ab == a9 then
            return aa
        end
    end
    return nil
end
local function ac(a9)
    if iskeypressed(a9) then
        if N[a9] then
            M[a9] = true
            L[a9] = true
            N[a9] = false
            return true
        else
            M[a9] = false
            L[a9] = true
        end
    else
        M[a9] = false
        L[a9] = false
        N[a9] = true
    end
    return false
end
local ad = {}
local function ae(a9)
    if not isrbxactive() then
        return false
    end
    if iskeypressed(a9) then
        if not ad[a9] then
            ad[a9] = true
            return true
        end
    else
        ad[a9] = false
    end
    return false
end
local af = {}
local ag = 0.4
local ah = 0.05
local function ai(a9)
    if not isrbxactive() then
        return false
    end
    local aj = os.clock()
    local ak = af[a9]
    if iskeypressed(a9) then
        if not ak then
            af[a9] = aj
            return true
        else
            local al = aj - ak
            if al >= ag then
                local am = math.floor((al - ag) / ah)
                local an = ak + ag + am * ah
                if aj - an >= ah then
                    return true
                end
            end
        end
    else
        af[a9] = nil
    end
    return false
end
local ao = {}
local function ap(a9)
    if not isrbxactive() then
        return false
    end
    local aq = ao[a9]
    local ar = iskeypressed(a9)
    ao[a9] = ar
    return ar and not aq
end
local as = {
    BASE = 1000,
    WINDOW = 2000,
    CONTROLS = 3000,
    DROPDOWN_BASE = 8000,
    DROPDOWN_OPTIONS = 9000,
    DROPDOWN_HOVER = 9500,
    DROPDOWN_TEXT = 9999,
    COLOR_PICKER = 10000
}
local function at(au, av, R)
    if av <= 0 then
        return R, R, R
    end
    au = au * 6
    local aw = R * av
    local ax = aw * (1 - math.abs(au % 2 - 1))
    local ay = R - aw
    local az, aA, aB = 0, 0, 0
    if au < 1 then
        az, aA, aB = aw, ax, 0
    elseif au < 2 then
        az, aA, aB = ax, aw, 0
    elseif au < 3 then
        az, aA, aB = 0, aw, ax
    elseif au < 4 then
        az, aA, aB = 0, ax, aw
    elseif au < 5 then
        az, aA, aB = ax, 0, aw
    else
        az, aA, aB = aw, 0, ax
    end
    return az + ay, aA + ay, aB + ay
end
local function aC(az, aA, aB)
    local aD = 255
    local aE = az / aD
    local aF = aA / aD
    local aG = aB / aD
    local f = math.max(aE, aF, aG)
    local e = math.min(aE, aF, aG)
    local aH = f - e
    local au, av, R
    R = f
    if f == 0 then
        av = 0
    else
        av = aH / f
    end
    if aH == 0 then
        au = 0
    else
        if f == aE then
            au = (aF - aG) / aH
            if aF < aG then
                au = au + 6
            end
        elseif f == aF then
            au = (aG - aE) / aH + 2
        else
            au = (aE - aF) / aH + 4
        end
        au = au / 6
    end
    return au, av, R
end
function UILib:CreateWindow(aI)
    local self = setmetatable({}, UILib)
    self.tabs = {}
    self.activeTab = nil
    self.name = aI.Name or "Window"
    self.loadingTitle = aI.LoadingTitle or "Loading..."
    self.loadingSubtitle = aI.LoadingSubtitle or ""
    self.theme = aI.Theme or "Default"
    self.toggleKey = aI.ToggleUIKeybind or "K"
    self.minimized = false
    self.notifications = {}
    self.base = Drawing.new("Square")
    self.base.Size = Vector2.new(n, o)
    self.base.Position = Vector2.new(l, m)
    self.base.Filled = true
    self.base.Color = x
    self.base.Visible = k
    self.base.Corner = 7
    self.base.ZIndex = V
    self.closeBox = Drawing.new("Square")
    self.closeBox.Size = Vector2.new(25, 25)
    self.closeBox.Position = Vector2.new(l + n - 30, m + 5)
    self.closeBox.Filled = true
    self.closeBox.Color = Color3.fromRGB(40, 40, 40)
    self.closeBox.Visible = false
    self.closeBox.Corner = 5
    self.closeBox.ZIndex = 10
    self.closeLine1 = Drawing.new("Line")
    self.closeLine1.From = Vector2.new(l + n - 25, m + 10)
    self.closeLine1.To = Vector2.new(l + n - 10, m + 25)
    self.closeLine1.Color = A
    self.closeLine1.Thickness = 2
    self.closeLine1.Visible = k
    self.closeLine1.ZIndex = 13
    self.closeLine2 = Drawing.new("Line")
    self.closeLine2.From = Vector2.new(l + n - 25, m + 25)
    self.closeLine2.To = Vector2.new(l + n - 10, m + 10)
    self.closeLine2.Color = A
    self.closeLine2.Thickness = 2
    self.closeLine2.Visible = k
    self.closeLine2.ZIndex = 13
    self.minimizeBox = Drawing.new("Square")
    self.minimizeBox.Size = Vector2.new(25, 25)
    self.minimizeBox.Position = Vector2.new(l + n - 60, m + 5)
    self.minimizeBox.Filled = true
    self.minimizeBox.Color = Color3.fromRGB(40, 40, 40)
    self.minimizeBox.Visible = false
    self.minimizeBox.Corner = 5
    self.minimizeBox.ZIndex = 13
    self.minimizeLine = Drawing.new("Line")
    self.minimizeLine.From = Vector2.new(l + n - 55, m + 17)
    self.minimizeLine.To = Vector2.new(l + n - 40, m + 17)
    self.minimizeLine.Color = A
    self.minimizeLine.Thickness = 2
    self.minimizeLine.Visible = k
    self.minimizeLine.ZIndex = 13
    self.title = Drawing.new("Text")
    self.title.Text = self.name
    self.title.Position = Vector2.new(l + 10, m + 10)
    self.title.Color = A
    self.title.Visible = k
    self.title.ZIndex = 12
    function self:CreateTab(aa)
        local aJ = #self.tabs + 1
        local aK = m + 50 + (aJ - 1) * (q + r)
        local aL = "tab_" .. aJ
        local aM = Drawing.new("Square")
        aM.Size = Vector2.new(p, q)
        aM.Position = Vector2.new(l + 10, aK)
        aM.Filled = true
        aM.Color = z
        aM.Visible = k
        aM.Corner = 5
        aM.ZIndex = W
        local aN = Drawing.new("Text")
        aN.Text = aa
        aN.Position = Vector2.new(l + 20, aK + 8)
        aN.Color = A
        aN.Visible = k
        aN.ZIndex = X
        local aO = Drawing.new("Square")
        aO.Size = Vector2.new(7, 20)
        aO.Position = Vector2.new(l + 10, aK + 5)
        aO.Filled = true
        aO.Color = y
        aO.Visible = false
        aO.Corner = 5
        aO.ZIndex = X
        local aP = {
            index = aJ,
            id = aL,
            name = aa,
            tab = aM,
            label = aN,
            indicator = aO,
            pos = Vector2.new(l + 10, aK),
            size = Vector2.new(p, q),
            items = {}
        }
        function aP:CreateButton(aI)
            return UILib:CreateButton(self, aI.Name, aI.Callback)
        end
        function aP:CreateToggle(aI)
            return UILib:CreateToggle(self, aI.Name, aI.CurrentValue, aI.Callback)
        end
        function aP:CreateSlider(aI)
            return UILib:CreateSlider(
                self,
                aI.Name,
                aI.Range[1],
                aI.Range[2],
                aI.CurrentValue,
                aI.Increment,
                aI.Callback
            )
        end
        function aP:CreateDropdown(aI)
            return UILib:CreateDropdown(self, aI.Name, aI.Options, aI.CurrentOption[1], aI.Callback, aI.MultipleOptions)
        end
        function aP:CreateTextbox(aI)
            return UILib:CreateTextbox(self, aI.Name, aI.Default, aI.PlaceholderText, aI.ClearTextOnFocus, aI.Callback)
        end
        function aP:CreateColorPicker(aI)
            return UILib:CreateColorPicker(self, aI.Name, aI.Default, aI.Callback)
        end
        K[aL] = false
        table.insert(self.tabs, aP)
        if not self.activeTab then
            self.activeTab = aP
            aO.Visible = true
        end
        return aP
    end
    return self
end
function UILib:CreateButton(aP, aQ, aR)
    local aS = "button_" .. #aP.items + 1
    local aT = Drawing.new("Square")
    aT.Filled = true
    aT.Corner = 5
    aT.ZIndex = X
    local aU = Drawing.new("Text")
    aU.Color = A
    aU.ZIndex = X + 1
    local aV = Drawing.new("Line")
    aV.Color = A
    aV.Thickness = 2
    aV.ZIndex = X + 2
    local aW = Drawing.new("Line")
    aW.Color = A
    aW.Thickness = 2
    aW.ZIndex = X + 2
    local aX = {
        type = "button",
        id = aS,
        container = aT,
        label = aU,
        arrowLine1 = aV,
        arrowLine2 = aW,
        callback = aR,
        text = aQ,
        containerPos = Vector2.new(0, 0),
        containerSize = Vector2.new(s, t),
        isHovered = false,
        wasPressed = false
    }
    J[aS] = false
    table.insert(aP.items, aX)
    return aX
end
function UILib:CreateToggle(aP, aQ, aY, aR)
    local aT = Drawing.new("Square")
    aT.Filled = true
    aT.Corner = 5
    aT.ZIndex = X
    local aZ = Drawing.new("Square")
    aZ.Filled = true
    aZ.Corner = 3
    aZ.ZIndex = X + 1
    local a_ = Drawing.new("Square")
    a_.Filled = true
    a_.Corner = 2
    a_.ZIndex = X + 2
    local aU = Drawing.new("Text")
    aU.Color = A
    aU.ZIndex = X + 1
    local aX = {
        type = "toggle",
        container = aT,
        box = aZ,
        fill = a_,
        label = aU,
        state = aY,
        callback = aR,
        text = aQ,
        containerPos = Vector2.new(0, 0),
        containerSize = Vector2.new(s, t),
        checkboxPos = Vector2.new(0, 0),
        checkboxSize = Vector2.new(v, v)
    }
    table.insert(aP.items, aX)
    return aX
end
function UILib:CreateSlider(aP, aQ, e, f, aY, b0, aR)
    local b1 = Drawing.new("Square")
    b1.Size = Vector2.new(10, 16)
    b1.Filled = true
    b1.Color = y
    b1.Visible = false
    b1.Corner = 3
    b1.ZIndex = X + 3
    local aT = Drawing.new("Square")
    aT.Filled = true
    aT.Corner = 5
    aT.ZIndex = X
    local b2 = Drawing.new("Square")
    b2.Filled = true
    b2.Corner = 3
    b2.ZIndex = X + 1
    local a_ = Drawing.new("Square")
    a_.Filled = true
    a_.Corner = 3
    a_.ZIndex = X + 2
    local aU = Drawing.new("Text")
    aU.Color = A
    aU.ZIndex = X + 1
    local b3 = Drawing.new("Text")
    b3.Color = A
    b3.ZIndex = X + 1
    local aX = {
        type = "slider",
        container = aT,
        bar = b2,
        fill = a_,
        label = aU,
        valueLabel = b3,
        indicator = b1,
        min = e,
        max = f,
        value = aY,
        step = b0,
        callback = aR,
        text = aQ,
        containerPos = Vector2.new(0, 0),
        containerSize = Vector2.new(s, t),
        sliderPos = Vector2.new(0, 0),
        sliderSize = Vector2.new(u, 10)
    }
    table.insert(aP.items, aX)
    return aX
end
function UILib:CreateDropdown(aP, aQ, b4, aY, aR, b5)
    local b6 = "dropdown_" .. #aP.items + 1
    local aT = Drawing.new("Square")
    aT.Filled = true
    aT.Color = z
    aT.Corner = 5
    aT.ZIndex = as.CONTROLS
    aT.Position = Vector2.new(0, 0)
    aT.Size = Vector2.new(s, t)
    local aU = Drawing.new("Text")
    aU.Text = aQ
    aU.Color = A
    aU.ZIndex = as.CONTROLS + 1
    aU.Position = Vector2.new(0, 0)
    local b7 = Drawing.new("Square")
    b7.Filled = true
    b7.Color = B
    b7.Corner = 5
    b7.ZIndex = as.CONTROLS + 2
    b7.Position = Vector2.new(0, 0)
    b7.Size = Vector2.new(120, 24)
    local b8 = Drawing.new("Text")
    b8.Color = A
    b8.ZIndex = as.CONTROLS + 3
    b8.Position = Vector2.new(0, 0)
    b8.Text = aY or b4[1]
    local b9 = Drawing.new("Square")
    b9.Filled = true
    b9.Color = z
    b9.Corner = 5
    b9.Visible = false
    b9.ZIndex = as.DROPDOWN_BASE
    b9.Position = Vector2.new(0, 0)
    b9.Size = Vector2.new(200, 200)
    local ba = {}
    for Q, bb in ipairs(b4) do
        local bc = Drawing.new("Square")
        bc.Filled = true
        bc.Color = B
        bc.Corner = 5
        bc.Visible = false
        bc.ZIndex = as.DROPDOWN_OPTIONS + Q * 2
        bc.Position = Vector2.new(0, 0)
        bc.Size = Vector2.new(190, 25)
        local bd = Drawing.new("Text")
        local be = tostring(bb)
        bd.Text = be
        bd.Color = A
        bd.Visible = false
        bd.ZIndex = as.DROPDOWN_OPTIONS + Q * 2 + 1
        bd.Position = Vector2.new(0, 0)
        table.insert(ba, {background = bc, label = bd, text = bb, isHovered = false, selected = false})
    end
    local aX = {
        type = "dropdown",
        id = b6,
        container = aT,
        label = aU,
        previewBox = b7,
        selectionText = b8,
        dropdownContainer = b9,
        options = ba,
        callback = aR,
        currentOption = aY or b4[1],
        selectedOptions = {},
        isOpen = false,
        text = aQ,
        containerPos = Vector2.new(0, 0),
        containerSize = Vector2.new(s, t),
        previewBoxSize = 120,
        dropdownWidth = 200,
        dropdownHeight = 200,
        optionHeight = 30,
        titleBg = nil,
        titleText = nil,
        multipleOptions = b5 or false
    }
    if b5 and type(aY) == "table" then
        for bf, bg in ipairs(aY) do
            aX.selectedOptions[bg] = true
        end
    end
    aX.titleBg = Drawing.new("Square")
    aX.titleBg.Filled = true
    aX.titleBg.Color = z
    aX.titleBg.Corner = 5
    aX.titleBg.ZIndex = as.DROPDOWN_OPTIONS
    aX.titleBg.Position = Vector2.new(0, 0)
    aX.titleBg.Size = Vector2.new(200, 35)
    aX.titleBg.Visible = false
    aX.titleText = Drawing.new("Text")
    aX.titleText.Color = A
    aX.titleText.ZIndex = as.DROPDOWN_OPTIONS + 1
    aX.titleText.Text = aQ
    aX.titleText.Position = Vector2.new(0, 0)
    aX.titleText.Visible = false
    function aX:UpdateDropdown(j, bh)
        if not bh then
            self.dropdownContainer.Visible = false
            if self.titleBg then
                self.titleBg.Visible = false
            end
            if self.titleText then
                self.titleText.Visible = false
            end
            for bf, bi in ipairs(self.options) do
                bi.background.Visible = false
                bi.label.Visible = false
            end
            return
        end
        self.container.Position = self.containerPos
        self.container.Size = self.containerSize
        self.container.Visible = true
        self.container.Color = z
        self.label.Position = Vector2.new(self.containerPos.x + 15, self.containerPos.y + self.containerSize.y / 2 - 7)
        self.label.Visible = true
        local bj = self.containerPos.x + self.containerSize.x - 120 - 15
        local bk = self.containerPos.y + (self.containerSize.y - 24) / 2
        self.previewBox.Position = Vector2.new(bj, bk)
        self.previewBox.Size = Vector2.new(120, 24)
        self.previewBox.Visible = true
        if self.multipleOptions then
            local bl = 0
            self.selectedOptions = self.selectedOptions or {}
            for bg, bm in pairs(self.selectedOptions) do
                if bm then
                    bl = bl + 1
                end
            end
            self.selectionText.Text = bl > 0 and bl .. " selected" or "None"
        else
            self.selectionText.Text = self.currentOption
        end
        self.selectionText.Position = Vector2.new(bj + 10, bk + 4)
        self.selectionText.Visible = true
        if self.isOpen then
            local bn = self.containerPos.x + self.containerSize.x + 10
            local bo = self.containerPos.y
            self.titleBg.Position = Vector2.new(bn, bo)
            self.titleBg.Size = Vector2.new(self.dropdownWidth, 35)
            self.titleBg.Visible = true
            self.titleText.Text = self.text
            self.titleText.Position = Vector2.new(bn + 10, bo + 10)
            self.titleText.Visible = true
            self.dropdownContainer.Position = Vector2.new(bn, bo)
            self.dropdownContainer.Size = Vector2.new(self.dropdownWidth, #self.options * self.optionHeight + 35)
            self.dropdownContainer.Visible = true
            for Q, bi in ipairs(self.options) do
                local bp = bo + 35 + (Q - 1) * self.optionHeight
                local bq = bn + 5
                bi.currentPos = Vector2.new(bq, bp)
                bi.currentSize = Vector2.new(self.dropdownWidth - 10, self.optionHeight - 5)
                bi.background.Position = bi.currentPos
                bi.background.Size = bi.currentSize
                bi.background.Visible = true
                bi.label.Position = Vector2.new(bn + 15, bp + 7)
                bi.label.Visible = true
                local br =
                    j.x >= bi.currentPos.x and j.x <= bi.currentPos.x + bi.currentSize.x and j.y >= bi.currentPos.y and
                    j.y <= bi.currentPos.y + bi.currentSize.y
                if self.multipleOptions then
                    bi.background.Color = self.selectedOptions[bi.text] and y or (br and D or B)
                else
                    bi.background.Color = bi.text == self.currentOption and y or (br and D or B)
                end
                bi.isHovered = br
                if br and H then
                    if self.multipleOptions then
                        self.selectedOptions[bi.text] = not self.selectedOptions[bi.text]
                        if self.callback then
                            local bs = {}
                            for bg, bm in pairs(self.selectedOptions) do
                                if bm then
                                    table.insert(bs, bg)
                                end
                            end
                            self.callback(bs)
                        end
                    else
                        self.currentOption = bi.text
                        if self.callback then
                            self.callback({bi.text})
                        end
                    end
                end
            end
        end
    end
    J[b6] = false
    table.insert(aP.items, aX)
    return aX
end
function UILib:CreateTextbox(aP, aQ, aY, bt, bu, aR)
    local bv = "textbox_" .. #aP.items + 1
    local aT = Drawing.new("Square")
    aT.Filled = true
    aT.Corner = 5
    aT.ZIndex = a1
    aT.Color = z
    aT.Position = Vector2.new(0, 0)
    aT.Size = Vector2.new(s, t)
    local aU = Drawing.new("Text")
    aU.Color = A
    aU.ZIndex = a1
    aU.Position = Vector2.new(0, 0)
    aU.Text = aQ
    local bw = Drawing.new("Square")
    bw.Filled = true
    bw.Color = a3
    bw.Corner = 5
    bw.ZIndex = a1
    bw.Position = Vector2.new(0, 0)
    bw.Size = Vector2.new(120, 24)
    local bx = Drawing.new("Text")
    bx.Color = A
    bx.ZIndex = a1 + 1
    bx.Position = Vector2.new(0, 0)
    bx.Text = aY or ""
    local aX = {
        type = "textbox",
        id = bv,
        container = aT,
        label = aU,
        inputBox = bw,
        inputText = bx,
        text = aQ,
        value = aY or "",
        placeholder = bt or "Type here...",
        clearOnFocus = bu or false,
        callback = aR,
        isFocused = false,
        containerPos = Vector2.new(0, 0),
        containerSize = Vector2.new(s, t),
        inputBoxWidth = 120
    }
    J[bv] = false
    table.insert(aP.items, aX)
    return aX
end
function UILib:CreateColorPicker(aP, aQ, aY, aR)
    local by = "colorpicker_" .. #aP.items + 1
    aY = Color3.fromRGB(255, 255, 255)
    local bz, bA, bB = aC(aY.R, aY.G, aY.B)
    local aT = Drawing.new("Square")
    aT.Filled = true
    aT.Color = z
    aT.Corner = 5
    aT.ZIndex = as.CONTROLS
    aT.Position = Vector2.new(0, 0)
    aT.Size = Vector2.new(s, t)
    local aU = Drawing.new("Text")
    aU.Text = aQ
    aU.Color = A
    aU.ZIndex = as.CONTROLS + 1
    aU.Position = Vector2.new(0, 0)
    local b7 = Drawing.new("Square")
    b7.Filled = true
    b7.Color = aY
    b7.Corner = 5
    b7.ZIndex = as.CONTROLS + 2
    b7.Position = Vector2.new(0, 0)
    b7.Size = Vector2.new(24, 24)
    local bC = Drawing.new("Square")
    bC.Filled = true
    bC.Color = z
    bC.Corner = 5
    bC.Visible = false
    bC.ZIndex = as.COLOR_PICKER
    bC.Position = Vector2.new(0, 0)
    bC.Size = Vector2.new(200, 250)
    local bD = Drawing.new("Square")
    bD.Filled = true
    bD.Color = aY
    bD.Corner = 5
    bD.Visible = false
    bD.ZIndex = as.COLOR_PICKER + 1
    bD.Position = Vector2.new(0, 0)
    bD.Size = Vector2.new(180, 40)
    local bE = Drawing.new("Square")
    bE.Filled = true
    bE.Color = Color3.fromRGB(255, 0, 0)
    bE.Corner = 5
    bE.Visible = false
    bE.ZIndex = as.COLOR_PICKER + 1
    bE.Position = Vector2.new(0, 0)
    bE.Size = Vector2.new(180, 25)
    local bF = Drawing.new("Square")
    bF.Filled = true
    bF.Color = Color3.fromRGB(255, 0, 0)
    bF.Corner = 5
    bF.Visible = false
    bF.ZIndex = as.COLOR_PICKER + 1
    bF.Position = Vector2.new(0, 0)
    bF.Size = Vector2.new(180, 25)
    local bG = Drawing.new("Square")
    bG.Filled = true
    bG.Color = Color3.fromRGB(255, 0, 0)
    bG.Corner = 5
    bG.Visible = false
    bG.ZIndex = as.COLOR_PICKER + 1
    bG.Position = Vector2.new(0, 0)
    bG.Size = Vector2.new(180, 25)
    local aX = {
        type = "colorpicker",
        id = by,
        container = aT,
        label = aU,
        previewBox = b7,
        pickerContainer = bC,
        selectedColorPreview = bD,
        hueGradient = bE,
        saturationGradient = bF,
        valueGradient = bG,
        callback = aR,
        currentColor = aY,
        isOpen = false,
        text = aQ,
        containerPos = Vector2.new(0, 0),
        containerSize = Vector2.new(s, t),
        previewBoxSize = 24,
        pickerWidth = 200,
        pickerHeight = 250,
        pickerPos = Vector2.new(0, 0),
        previewPos = Vector2.new(0, 0),
        huePos = Vector2.new(0, 0),
        hueSize = Vector2.new(180, 25),
        saturationPos = Vector2.new(0, 0),
        saturationSize = Vector2.new(180, 25),
        valuePos = Vector2.new(0, 0),
        valueSize = Vector2.new(180, 25),
        selectedPreviewPos = Vector2.new(0, 0),
        selectedPreviewSize = Vector2.new(180, 40),
        hue = bz or 0,
        saturation = bA or 1,
        value = bB or 1,
        titleBg = nil,
        titleText = nil,
        hueSegments = {},
        saturationSegments = {},
        valueSegments = {}
    }
    aX.titleBg = Drawing.new("Square")
    aX.titleBg.Filled = true
    aX.titleBg.Color = z
    aX.titleBg.Corner = 5
    aX.titleBg.ZIndex = as.COLOR_PICKER
    aX.titleBg.Position = Vector2.new(0, 0)
    aX.titleBg.Size = Vector2.new(200, 35)
    aX.titleBg.Visible = false
    aX.titleText = Drawing.new("Text")
    aX.titleText.Color = A
    aX.titleText.ZIndex = as.COLOR_PICKER + 1
    aX.titleText.Text = aQ
    aX.titleText.Position = Vector2.new(0, 0)
    aX.titleText.Visible = false
    function aX:UpdateColor()
        local az, aA, aB = at(self.hue, self.saturation, self.value)
        az = math.floor(az * 255)
        aA = math.floor(aA * 255)
        aB = math.floor(aB * 255)
        self.currentColor = Color3.fromRGB(az, aA, aB)
        self.previewBox.Color = self.currentColor
        self.selectedColorPreview.Color = self.currentColor
        if self.callback then
            self.callback(self.currentColor)
        end
    end
    function aX:UpdateColorPicker(j, bh)
        if not bh or not self.isOpen then
            self.pickerContainer.Visible = false
            self.selectedColorPreview.Visible = false
            self.hueGradient.Visible = false
            self.saturationGradient.Visible = false
            self.valueGradient.Visible = false
            if self.titleBg then
                self.titleBg.Visible = false
            end
            if self.titleText then
                self.titleText.Visible = false
            end
            if self.hueSegments then
                for bf, bH in ipairs(self.hueSegments) do
                    bH.Visible = false
                end
            end
            if self.saturationSegments then
                for bf, bH in ipairs(self.saturationSegments) do
                    bH.Visible = false
                end
            end
            if self.valueSegments then
                for bf, bH in ipairs(self.valueSegments) do
                    bH.Visible = false
                end
            end
            return
        end
        self.container.Position = self.containerPos
        self.container.Size = self.containerSize
        self.container.Visible = true
        self.container.Color = z
        self.label.Position = Vector2.new(self.containerPos.x + 15, self.containerPos.y + self.containerSize.y / 2 - 7)
        self.label.Visible = true
        local bj = self.containerPos.x + self.containerSize.x - self.previewBoxSize - 15
        local bk = self.containerPos.y + (self.containerSize.y - self.previewBoxSize) / 2
        self.previewPos = Vector2.new(bj, bk)
        self.previewBox.Position = self.previewPos
        self.previewBox.Size = Vector2.new(self.previewBoxSize, self.previewBoxSize)
        self.previewBox.Visible = true
        if self.isOpen then
            local bn = self.containerPos.x + self.containerSize.x + 10
            local bo = self.containerPos.y
            self.pickerPos = Vector2.new(bn, bo)
            self.pickerContainer.Position = self.pickerPos
            self.pickerContainer.Size = Vector2.new(self.pickerWidth, self.pickerHeight)
            self.pickerContainer.Visible = true
            self.titleBg.Position = Vector2.new(bn, bo)
            self.titleBg.Size = Vector2.new(self.pickerWidth, 35)
            self.titleBg.Visible = true
            self.titleText.Text = self.text
            self.titleText.Position = Vector2.new(bn + 10, bo + 10)
            self.titleText.Visible = true
            self.selectedPreviewPos = Vector2.new(bn + 10, bo + 45)
            self.selectedPreviewSize = Vector2.new(self.pickerWidth - 20, 40)
            self.selectedColorPreview.Position = self.selectedPreviewPos
            self.selectedColorPreview.Size = self.selectedPreviewSize
            self.selectedColorPreview.Visible = true
            self.huePos = Vector2.new(bn + 10, bo + 95)
            self.hueSize = Vector2.new(self.pickerWidth - 20, 25)
            self.hueGradient.Position = self.huePos
            self.hueGradient.Size = self.hueSize
            self.hueGradient.Visible = true
            self.saturationPos = Vector2.new(bn + 10, bo + 130)
            self.saturationSize = Vector2.new(self.pickerWidth - 20, 25)
            self.saturationGradient.Position = self.saturationPos
            self.saturationGradient.Size = self.saturationSize
            self.saturationGradient.Visible = true
            self.valuePos = Vector2.new(bn + 10, bo + 165)
            self.valueSize = Vector2.new(self.pickerWidth - 20, 25)
            self.valueGradient.Position = self.valuePos
            self.valueGradient.Size = self.valueSize
            self.valueGradient.Visible = true
            local bI = 36
            local bJ = self.hueSize.x / bI
            for Q = 0, bI - 1 do
                if not self.hueSegments[Q + 1] then
                    self.hueSegments[Q + 1] = Drawing.new("Square")
                    self.hueSegments[Q + 1].Filled = true
                    self.hueSegments[Q + 1].ZIndex = self.hueGradient.ZIndex
                    self.hueSegments[Q + 1].Corner = 0
                end
                local bH = self.hueSegments[Q + 1]
                local bK = Q / bI
                local az, aA, aB = at(bK, 1, 1)
                bH.Position = Vector2.new(self.huePos.x + Q * bJ, self.huePos.y)
                bH.Size = Vector2.new(bJ + 0.5, self.hueSize.y)
                bH.Color = Color3.fromRGB(az * 255, aA * 255, aB * 255)
                bH.Visible = true
            end
            local bL, bM, bN = at(self.hue, 1, self.value)
            for Q = 0, bI - 1 do
                if not self.saturationSegments[Q + 1] then
                    self.saturationSegments[Q + 1] = Drawing.new("Square")
                    self.saturationSegments[Q + 1].Filled = true
                    self.saturationSegments[Q + 1].ZIndex = self.saturationGradient.ZIndex
                    self.saturationSegments[Q + 1].Corner = 0
                end
                local bH = self.saturationSegments[Q + 1]
                local bO = Q / bI
                local az = bL * bO + 1 - bO
                local aA = bM * bO + 1 - bO
                local aB = bN * bO + 1 - bO
                bH.Position = Vector2.new(self.saturationPos.x + Q * bJ, self.saturationPos.y)
                bH.Size = Vector2.new(bJ + 0.5, self.saturationSize.y)
                bH.Color = Color3.fromRGB(az * 255, aA * 255, aB * 255)
                bH.Visible = true
            end
            local bL, bM, bN = at(self.hue, self.saturation, 1)
            for Q = 0, bI - 1 do
                if not self.valueSegments[Q + 1] then
                    self.valueSegments[Q + 1] = Drawing.new("Square")
                    self.valueSegments[Q + 1].Filled = true
                    self.valueSegments[Q + 1].ZIndex = self.valueGradient.ZIndex
                    self.valueSegments[Q + 1].Corner = 0
                end
                local bH = self.valueSegments[Q + 1]
                local d = Q / bI
                bH.Position = Vector2.new(self.valuePos.x + Q * bJ, self.valuePos.y)
                bH.Size = Vector2.new(bJ + 0.5, self.valueSize.y)
                bH.Color = Color3.fromRGB(bL * 255 * d, bM * 255 * d, bN * 255 * d)
                bH.Visible = true
            end
            local bP =
                j.x >= self.huePos.x and j.x <= self.huePos.x + self.hueSize.x and j.y >= self.huePos.y and
                j.y <= self.huePos.y + self.hueSize.y
            if bP and G then
                local bQ = (j.x - self.huePos.x) / self.hueSize.x
                self.hue = c(bQ, 0, 1)
                self:UpdateColor()
            end
            local bR =
                j.x >= self.saturationPos.x and j.x <= self.saturationPos.x + self.saturationSize.x and
                j.y >= self.saturationPos.y and
                j.y <= self.saturationPos.y + self.saturationSize.y
            if bR and G then
                local bQ = (j.x - self.saturationPos.x) / self.saturationSize.x
                self.saturation = c(bQ, 0, 1)
                self:UpdateColor()
            end
            local bS =
                j.x >= self.valuePos.x and j.x <= self.valuePos.x + self.valueSize.x and j.y >= self.valuePos.y and
                j.y <= self.valuePos.y + self.valueSize.y
            if bS and G then
                local bQ = (j.x - self.valuePos.x) / self.valueSize.x
                self.value = c(bQ, 0, 1)
                self:UpdateColor()
            end
        end
    end
    function aX:Destroy()
        if self.container then
            self.container:Remove()
        end
        if self.label then
            self.label:Remove()
        end
        if self.previewBox then
            self.previewBox:Remove()
        end
        if self.pickerContainer then
            self.pickerContainer:Remove()
        end
        if self.selectedColorPreview then
            self.selectedColorPreview:Remove()
        end
        if self.hueGradient then
            self.hueGradient:Remove()
        end
        if self.saturationGradient then
            self.saturationGradient:Remove()
        end
        if self.valueGradient then
            self.valueGradient:Remove()
        end
        if self.titleBg then
            self.titleBg:Remove()
        end
        if self.titleText then
            self.titleText:Remove()
        end
        if self.hueSegments then
            for bf, bH in ipairs(self.hueSegments) do
                bH:Remove()
            end
        end
        if self.saturationSegments then
            for bf, bH in ipairs(self.saturationSegments) do
                bH:Remove()
            end
        end
        if self.valueSegments then
            for bf, bH in ipairs(self.valueSegments) do
                bH:Remove()
            end
        end
    end
    aU.Text = aQ
    aX:UpdateColor()
    J[by] = false
    table.insert(aP.items, aX)
    return aX
end
function UILib:Step()
    local j = g()
    H = false
    if ismouse1pressed() then
        if not G then
            H = true
        end
        G = true
    else
        G = false
    end
    if self.toggleKey then
        local a9 = a7[self.toggleKey:upper()]
        if a9 and ac(a9) and isrbxactive() then
            k = not k
            self:CloseAllDropdownsAndColorPickers()
            self.base.Visible = k
            self.title.Visible = k
            self.closeLine1.Visible = k
            self.closeLine2.Visible = k
            self.minimizeLine.Visible = k
            self.closeBox.Visible = false
            self.minimizeBox.Visible = false
            for bf, aM in ipairs(self.tabs) do
                aM.tab.Visible = k and not self.minimized
                aM.label.Visible = k and not self.minimized
                aM.indicator.Visible = k and not self.minimized and aM == self.activeTab
                for bf, aX in ipairs(aM.items) do
                    local bT = k and not self.minimized and aM == self.activeTab
                    if aX.container then
                        aX.container.Visible = bT
                    end
                    if aX.label then
                        aX.label.Visible = bT
                    end
                    if aX.box then
                        aX.box.Visible = bT
                    end
                    if aX.fill then
                        aX.fill.Visible = bT and aX.state
                    end
                    if aX.bar then
                        aX.bar.Visible = bT
                    end
                    if aX.indicator then
                        aX.indicator.Visible = bT
                    end
                    if aX.valueLabel then
                        aX.valueLabel.Visible = bT
                    end
                    if aX.previewBox then
                        aX.previewBox.Visible = bT
                    end
                    if aX.selectionText then
                        aX.selectionText.Visible = bT
                    end
                    if aX.inputBox then
                        aX.inputBox.Visible = bT
                    end
                    if aX.inputText then
                        aX.inputText.Visible = bT
                    end
                    if aX.cursor then
                        aX.cursor.Visible = false
                    end
                    if aX.type == "dropdown" or aX.type == "colorpicker" then
                        aX.isOpen = false
                    end
                end
            end
        end
    end
    function UILib:CreateDropdown(aP, aQ, b4, aY, aR, b5)
        local b6 = "dropdown_" .. #aP.items + 1
        local aT = Drawing.new("Square")
        aT.Filled = true
        aT.Color = z
        aT.Corner = 5
        aT.ZIndex = as.CONTROLS
        aT.Position = Vector2.new(0, 0)
        aT.Size = Vector2.new(s, t)
        local aU = Drawing.new("Text")
        aU.Text = aQ
        aU.Color = A
        aU.ZIndex = as.CONTROLS + 1
        aU.Position = Vector2.new(0, 0)
        local b7 = Drawing.new("Square")
        b7.Filled = true
        b7.Color = B
        b7.Corner = 5
        b7.ZIndex = as.CONTROLS + 2
        b7.Position = Vector2.new(0, 0)
        b7.Size = Vector2.new(120, 24)
        local b8 = Drawing.new("Text")
        b8.Color = A
        b8.ZIndex = as.CONTROLS + 3
        b8.Position = Vector2.new(0, 0)
        b8.Text = aY or b4[1]
        local b9 = Drawing.new("Square")
        b9.Filled = true
        b9.Color = z
        b9.Corner = 5
        b9.Visible = false
        b9.ZIndex = as.DROPDOWN_BASE
        b9.Position = Vector2.new(0, 0)
        b9.Size = Vector2.new(200, 200)
        local ba = {}
        for Q, bb in ipairs(b4) do
            local bc = Drawing.new("Square")
            bc.Filled = true
            bc.Color = B
            bc.Corner = 5
            bc.Visible = false
            bc.ZIndex = as.DROPDOWN_OPTIONS + Q * 2
            bc.Position = Vector2.new(0, 0)
            bc.Size = Vector2.new(190, 25)
            local bd = Drawing.new("Text")
            local be = tostring(bb)
            bd.Text = be
            bd.Color = A
            bd.Visible = false
            bd.ZIndex = as.DROPDOWN_OPTIONS + Q * 2 + 1
            bd.Position = Vector2.new(0, 0)
            table.insert(ba, {background = bc, label = bd, text = bb, isHovered = false, selected = false})
        end
        local aX = {
            type = "dropdown",
            id = b6,
            container = aT,
            label = aU,
            previewBox = b7,
            selectionText = b8,
            dropdownContainer = b9,
            options = ba,
            callback = aR,
            currentOption = aY or b4[1],
            selectedOptions = {},
            isOpen = false,
            text = aQ,
            containerPos = Vector2.new(0, 0),
            containerSize = Vector2.new(s, t),
            previewBoxSize = 120,
            dropdownWidth = 200,
            dropdownHeight = 200,
            optionHeight = 30,
            titleBg = nil,
            titleText = nil,
            multipleOptions = b5 or false
        }
        if b5 and type(aY) == "table" then
            for bf, bg in ipairs(aY) do
                aX.selectedOptions[bg] = true
            end
        end
        aX.titleBg = Drawing.new("Square")
        aX.titleBg.Filled = true
        aX.titleBg.Color = z
        aX.titleBg.Corner = 5
        aX.titleBg.ZIndex = as.DROPDOWN_OPTIONS
        aX.titleBg.Position = Vector2.new(0, 0)
        aX.titleBg.Size = Vector2.new(200, 35)
        aX.titleBg.Visible = false
        aX.titleText = Drawing.new("Text")
        aX.titleText.Color = A
        aX.titleText.ZIndex = as.DROPDOWN_OPTIONS + 1
        aX.titleText.Text = aQ
        aX.titleText.Position = Vector2.new(0, 0)
        aX.titleText.Visible = false
        function aX:UpdateDropdown(j, bh)
            if not bh then
                self.dropdownContainer.Visible = false
                if self.titleBg then
                    self.titleBg.Visible = false
                end
                if self.titleText then
                    self.titleText.Visible = false
                end
                for bf, bi in ipairs(self.options) do
                    bi.background.Visible = false
                    bi.label.Visible = false
                end
                return
            end
            self.container.Position = self.containerPos
            self.container.Size = self.containerSize
            self.container.Visible = true
            self.container.Color = z
            self.label.Position =
                Vector2.new(self.containerPos.x + 15, self.containerPos.y + self.containerSize.y / 2 - 7)
            self.label.Visible = true
            local bj = self.containerPos.x + self.containerSize.x - 120 - 15
            local bk = self.containerPos.y + (self.containerSize.y - 24) / 2
            self.previewBox.Position = Vector2.new(bj, bk)
            self.previewBox.Size = Vector2.new(120, 24)
            self.previewBox.Visible = true
            if self.multipleOptions then
                local bl = 0
                self.selectedOptions = self.selectedOptions or {}
                for bg, bm in pairs(self.selectedOptions) do
                    if bm then
                        bl = bl + 1
                    end
                end
                self.selectionText.Text = bl > 0 and bl .. " selected" or "None"
            else
                self.selectionText.Text = self.currentOption
            end
            self.selectionText.Position = Vector2.new(bj + 10, bk + 4)
            self.selectionText.Visible = true
            if self.isOpen then
                local bn = self.containerPos.x + self.containerSize.x + 10
                local bo = self.containerPos.y
                self.titleBg.Position = Vector2.new(bn, bo)
                self.titleBg.Size = Vector2.new(self.dropdownWidth, 35)
                self.titleBg.Visible = true
                self.titleText.Text = self.text
                self.titleText.Position = Vector2.new(bn + 10, bo + 10)
                self.titleText.Visible = true
                self.dropdownContainer.Position = Vector2.new(bn, bo)
                self.dropdownContainer.Size = Vector2.new(self.dropdownWidth, #self.options * self.optionHeight + 35)
                self.dropdownContainer.Visible = true
                for Q, bi in ipairs(self.options) do
                    local bp = bo + 35 + (Q - 1) * self.optionHeight
                    local bq = bn + 5
                    bi.currentPos = Vector2.new(bq, bp)
                    bi.currentSize = Vector2.new(self.dropdownWidth - 10, self.optionHeight - 5)
                    bi.background.Position = bi.currentPos
                    bi.background.Size = bi.currentSize
                    bi.background.Visible = true
                    bi.label.Position = Vector2.new(bn + 15, bp + 7)
                    bi.label.Visible = true
                    local br =
                        j.x >= bi.currentPos.x and j.x <= bi.currentPos.x + bi.currentSize.x and j.y >= bi.currentPos.y and
                        j.y <= bi.currentPos.y + bi.currentSize.y
                    if self.multipleOptions then
                        bi.background.Color = self.selectedOptions[bi.text] and y or (br and D or B)
                    else
                        bi.background.Color = bi.text == self.currentOption and y or (br and D or B)
                    end
                    bi.isHovered = br
                    if br and H then
                        if self.multipleOptions then
                            self.selectedOptions[bi.text] = not self.selectedOptions[bi.text]
                            if self.callback then
                                local bs = {}
                                for bg, bm in pairs(self.selectedOptions) do
                                    if bm then
                                        table.insert(bs, bg)
                                    end
                                end
                                self.callback(bs)
                            end
                        else
                            self.currentOption = bi.text
                            if self.callback then
                                self.callback({bi.text})
                            end
                        end
                    end
                end
            end
        end
        J[b6] = false
        table.insert(aP.items, aX)
        return aX
    end
    if not k then
        return
    end
    self:UpdateNotifications()
    local bU = UILib._IsMouseWithinBounds(Vector2.new(l + n - 30, m + 5), Vector2.new(25, 25))
    self.closeBox.Visible = bU
    if bU and H then
        self:Destroy()
        return
    end
    local bV = UILib._IsMouseWithinBounds(Vector2.new(l + n - 60, m + 5), Vector2.new(25, 25))
    self.minimizeBox.Visible = bV
    if bV and H then
        self.minimized = not self.minimized
        for bf, aM in ipairs(self.tabs) do
            for bf, aX in ipairs(aM.items) do
                if aX.type == "colorpicker" then
                    aX.isOpen = false
                    if aX.pickerContainer then
                        aX.pickerContainer.Visible = false
                    end
                    if aX.selectedColorPreview then
                        aX.selectedColorPreview.Visible = false
                    end
                    if aX.hueGradient then
                        aX.hueGradient.Visible = false
                    end
                    if aX.valueGradient then
                        aX.valueGradient.Visible = false
                    end
                    if aX.titleBg then
                        aX.titleBg.Visible = false
                    end
                    if aX.titleText then
                        aX.titleText.Visible = false
                    end
                    if aX.hueSegments then
                        for bf, bH in ipairs(aX.hueSegments) do
                            bH.Visible = false
                        end
                    end
                    if aX.valueSegments then
                        for bf, bH in ipairs(aX.valueSegments) do
                            bH.Visible = false
                        end
                    end
                end
            end
        end
        self.base.Size = Vector2.new(n, self.minimized and 35 or o)
        for bf, aM in ipairs(self.tabs) do
            aM.tab.Visible = not self.minimized
            aM.label.Visible = not self.minimized
            aM.indicator.Visible = not self.minimized and aM == self.activeTab
            for bf, aX in ipairs(aM.items) do
                if aX.container then
                    aX.container.Visible = not self.minimized and aM == self.activeTab
                end
                if aX.label then
                    aX.label.Visible = not self.minimized and aM == self.activeTab
                end
                if aX.box then
                    aX.box.Visible = not self.minimized and aM == self.activeTab
                end
                if aX.fill then
                    aX.fill.Visible = not self.minimized and aM == self.activeTab and aX.state
                end
                if aX.bar then
                    aX.bar.Visible = not self.minimized and aM == self.activeTab
                end
                if aX.indicator then
                    aX.indicator.Visible = not self.minimized and aM == self.activeTab
                end
                if aX.valueLabel then
                    aX.valueLabel.Visible = not self.minimized and aM == self.activeTab
                end
            end
        end
    end
    if H and UILib._IsMouseWithinBounds(Vector2.new(l, m), Vector2.new(n - 65, 30)) and not E then
        E = true
        F = Vector2.new(j.x - l, j.y - m)
    elseif not ismouse1pressed() then
        E = false
    end
    if E then
        l = j.x - F.x
        m = j.y - F.y
        self.base.Position = Vector2.new(l, m)
        self.title.Position = Vector2.new(l + 10, m + 10)
        self.closeBox.Position = Vector2.new(l + n - 30, m + 5)
        self.closeLine1.From = Vector2.new(l + n - 25, m + 10)
        self.closeLine1.To = Vector2.new(l + n - 10, m + 25)
        self.closeLine2.From = Vector2.new(l + n - 25, m + 25)
        self.closeLine2.To = Vector2.new(l + n - 10, m + 10)
        self.minimizeBox.Position = Vector2.new(l + n - 60, m + 5)
        self.minimizeLine.From = Vector2.new(l + n - 55, m + 17)
        self.minimizeLine.To = Vector2.new(l + n - 40, m + 17)
        for bf, aM in ipairs(self.tabs) do
            local aK = m + 50 + (aM.index - 1) * (q + r)
            aM.tab.Position = Vector2.new(l + 10, aK)
            aM.label.Position = Vector2.new(l + 20, aK + 8)
            aM.indicator.Position = Vector2.new(l + 10, aK + 5)
            aM.pos = Vector2.new(l + 10, aK)
            aM.tab.Visible = not self.minimized
            aM.label.Visible = not self.minimized
            aM.indicator.Visible = not self.minimized and aM == self.activeTab
        end
    end
    if H and not E and not self.minimized then
        for bf, aM in ipairs(self.tabs) do
            if UILib._IsMouseWithinBounds(aM.pos, aM.size) then
                for bf, bW in ipairs(self.tabs) do
                    for bf, aX in ipairs(bW.items) do
                        if aX.type == "colorpicker" then
                            aX.isOpen = false
                            if aX.pickerContainer then
                                aX.pickerContainer.Visible = false
                            end
                            if aX.selectedColorPreview then
                                aX.selectedColorPreview.Visible = false
                            end
                            if aX.hueGradient then
                                aX.hueGradient.Visible = false
                            end
                            if aX.valueGradient then
                                aX.valueGradient.Visible = false
                            end
                            if aX.titleBg then
                                aX.titleBg.Visible = false
                            end
                            if aX.titleText then
                                aX.titleText.Visible = false
                            end
                            if aX.hueSegments then
                                for bf, bH in ipairs(aX.hueSegments) do
                                    bH.Visible = false
                                end
                            end
                            if aX.valueSegments then
                                for bf, bH in ipairs(aX.valueSegments) do
                                    bH.Visible = false
                                end
                            end
                        end
                    end
                end
                self.activeTab = aM
                for bf, bW in ipairs(self.tabs) do
                    bW.indicator.Visible = not self.minimized and bW == aM
                end
            end
        end
    end
    for bf, aM in ipairs(self.tabs) do
        local bX = not self.minimized and UILib._IsMouseWithinBounds(aM.pos, aM.size)
        if bX and not K[aM.id] then
            K[aM.id] = true
        elseif not bX and K[aM.id] then
            K[aM.id] = false
        end
        aM.indicator.Visible = not self.minimized and aM == self.activeTab
        aM.tab.Color = K[aM.id] and C or z
    end
    for bf, aM in ipairs(self.tabs) do
        local bT = aM == self.activeTab and not self.minimized
        for Q, aX in ipairs(aM.items) do
            local bY = m + 50 + (Q - 1) * (t + r)
            local bZ = l + 130
            aX.containerPos = Vector2.new(bZ, bY)
            aX.container.Position = aX.containerPos
            aX.container.Size = aX.containerSize
            aX.container.Filled = true
            aX.container.Visible = bT
            aX.container.Corner = 5
            if aX.type == "button" then
                aX.label.Text = aX.text
                aX.label.Position = Vector2.new(bZ + 15, bY + t / 2 - 7)
                aX.label.Color = A
                aX.label.Visible = bT
                local bX = UILib._IsMouseWithinBounds(aX.containerPos, aX.containerSize)
                if bX and not J[aX.id] then
                    J[aX.id] = true
                elseif not bX and J[aX.id] then
                    J[aX.id] = false
                end
                aX.container.Color = J[aX.id] and C or z
                local b_ = bZ + s - 25
                local c0 = bY + t / 2
                local c1 = 6
                aX.arrowLine1.From = Vector2.new(b_, c0 - c1)
                aX.arrowLine1.To = Vector2.new(b_ + c1, c0)
                aX.arrowLine1.Visible = bT
                aX.arrowLine2.From = Vector2.new(b_, c0 + c1)
                aX.arrowLine2.To = Vector2.new(b_ + c1, c0)
                aX.arrowLine2.Visible = bT
                if bX and H and bT and aX.callback then
                    aX.callback()
                end
            elseif aX.type == "toggle" then
                aX.label.Text = aX.text
                aX.label.Position = Vector2.new(bZ + 15, bY + t / 2 - 7)
                aX.label.Color = A
                aX.label.Visible = bT
                local c2 = bZ + s - aX.checkboxSize.x - 15
                local c3 = bY + t / 2 - aX.checkboxSize.y / 2
                aX.checkboxPos = Vector2.new(c2, c3)
                aX.box.Position = aX.checkboxPos
                aX.box.Size = aX.checkboxSize
                aX.box.Filled = true
                aX.box.Color = B
                aX.box.Corner = 3
                aX.box.Visible = bT
                aX.fill.Position = Vector2.new(c2 + 3, c3 + 3)
                aX.fill.Size = Vector2.new(aX.checkboxSize.x - 6, aX.checkboxSize.y - 6)
                aX.fill.Filled = true
                aX.fill.Color = y
                aX.fill.Corner = 2
                aX.fill.Visible = bT and aX.state
                local c4 = UILib._IsMouseWithinBounds(aX.checkboxPos, aX.checkboxSize)
                if c4 and H and bT then
                    aX.state = not aX.state
                    if aX.callback then
                        aX.callback(aX.state)
                    end
                end
                aX.container.Color = z
            elseif aX.type == "slider" then
                aX.label.Text = aX.text
                aX.label.Position = Vector2.new(bZ + 15, bY + t / 2 - 7)
                aX.label.Color = A
                aX.label.Visible = bT
                local c5 = bZ + s - aX.sliderSize.x - 40
                local c6 = bY + t / 2 - aX.sliderSize.y / 2
                aX.sliderPos = Vector2.new(c5, c6)
                local c7 = (aX.value - aX.min) / (aX.max - aX.min)
                local c8 = aX.sliderSize.x * c7
                aX.bar.Position = aX.sliderPos
                aX.bar.Size = aX.sliderSize
                aX.bar.Filled = true
                aX.bar.Color = B
                aX.bar.Corner = 3
                aX.bar.Visible = bT
                aX.fill.Position = aX.sliderPos
                aX.fill.Size = Vector2.new(c8, aX.sliderSize.y)
                aX.fill.Filled = true
                aX.fill.Color = y
                aX.fill.Corner = 3
                aX.fill.Visible = bT
                local c9 = aX.sliderPos.x + c8 - 5
                local ca = aX.sliderPos.y - 3
                aX.indicator.Position = Vector2.new(c9, ca)
                aX.indicator.Visible = bT
                aX.valueLabel.Text = tostring(aX.value)
                aX.valueLabel.Position = Vector2.new(c5 - 30, bY + t / 2 - 7)
                aX.valueLabel.Color = A
                aX.valueLabel.Visible = bT
                aX.container.Color = z
                local c4 = UILib._IsMouseWithinBounds(aX.sliderPos, aX.sliderSize)
                if c4 and G and bT then
                    local cb = c(j.x - aX.sliderPos.x, 0, aX.sliderSize.x)
                    local cc = cb / aX.sliderSize.X
                    local cd = math.floor((aX.min + (aX.max - aX.min) * cc) / aX.step + 0.5) * aX.step
                    cd = c(cd, aX.min, aX.max)
                    aX.value = cd
                    aX.valueLabel.Text = tostring(cd)
                    if aX.callback then
                        aX.callback(cd)
                    end
                end
            elseif aX.type == "dropdown" then
                local bh = k and not self.minimized and aM == self.activeTab
                aX.container.Visible = bh
                aX.label.Visible = bh
                aX.previewBox.Visible = bh
                aX.selectionText.Visible = bh
                if bh then
                    local bj = aX.containerPos.x + aX.containerSize.x - 120 - 15
                    local bk = aX.containerPos.y + (aX.containerSize.y - 24) / 2
                    local ce = j.x >= bj and j.x <= bj + 120 and j.y >= bk and j.y <= bk + 24
                    if ce and H then
                        if not aX.isOpen then
                            self:CloseAllDropdownsAndColorPickers()
                            aX.isOpen = true
                        else
                            aX.isOpen = false
                            if aX.dropdownContainer then
                                aX.dropdownContainer.Visible = false
                            end
                            if aX.titleBg then
                                aX.titleBg.Visible = false
                            end
                            if aX.titleText then
                                aX.titleText.Visible = false
                            end
                            for bf, bi in ipairs(aX.options) do
                                bi.background.Visible = false
                                bi.label.Visible = false
                            end
                        end
                    elseif
                        H and aX.pickerContainer and
                            not (j.x >= aX.pickerPos.x and j.x <= aX.pickerPos.x + aX.pickerWidth and
                                j.y >= aX.pickerPos.y and
                                j.y <= aX.pickerPos.y + aX.pickerHeight)
                     then
                        aX.isOpen = false
                    end
                    aX:UpdateDropdown(j, bh)
                else
                    aX.isOpen = false
                    if aX.dropdownContainer then
                        aX.dropdownContainer.Visible = false
                    end
                    if aX.titleBg then
                        aX.titleBg.Visible = false
                    end
                    if aX.titleText then
                        aX.titleText.Visible = false
                    end
                    for bf, bi in ipairs(aX.options) do
                        bi.background.Visible = false
                        bi.label.Visible = false
                    end
                end
            elseif aX.type == "textbox" then
                local bh = k and not self.minimized and aM == self.activeTab
                aX.container.Visible = bh
                aX.label.Visible = bh
                aX.inputBox.Visible = bh
                aX.inputText.Visible = bh
                if bh then
                    aX.label.Text = aX.text
                    aX.label.Position = Vector2.new(bZ + 15, bY + t / 2 - 7)
                    aX.label.Color = A
                    local cf = aX.inputBoxWidth
                    local cg = bZ + s - cf - 15
                    local ch = bY + t / 2 - 12
                    aX.inputBox.Size = Vector2.new(cf, 24)
                    aX.inputBox.Position = Vector2.new(cg, ch)
                    aX.inputBox.Color = aX.isFocused and a2 or a3
                    aX.inputText.Text = aX.value == "" and aX.placeholder or aX.value
                    aX.inputText.Position = Vector2.new(cg + 8, ch + 4)
                    aX.inputText.Color = aX.value == "" and Color3.fromRGB(100, 100, 100) or A
                    local ci = UILib._IsMouseWithinBounds(Vector2.new(cg, ch), Vector2.new(cf, 24))
                    if H then
                        local cj = aX.isFocused
                        aX.isFocused = ci
                        if aX.isFocused and not cj and aX.clearOnFocus then
                            aX.value = ""
                        end
                    end
                    if aX.isFocused and isrbxactive() then
                        if aX.text == "Toggle Key" then
                            for a9 = 0x01, 0xFF do
                                if ac(a9) then
                                    local ck = a8(a9)
                                    if ck then
                                        aX.value = ck
                                        if aX.callback then
                                            aX.callback(ck)
                                        end
                                    end
                                end
                            end
                        else
                            for Q = 32, 126 do
                                if ac(Q) then
                                    aX.value = aX.value .. string.char(Q)
                                    if aX.callback then
                                        aX.callback(aX.value)
                                    end
                                end
                            end
                        end
                        if ac(0x08) then
                            if #aX.value > 0 then
                                aX.value = aX.value:sub(1, -2)
                                if aX.callback then
                                    aX.callback(aX.value)
                                end
                            end
                        end
                    end
                    aX.container.Color = z
                end
            elseif aX.type == "colorpicker" then
                local bh = k and not self.minimized and aM == self.activeTab
                aX.container.Position = aX.containerPos
                aX.container.Size = aX.containerSize
                aX.container.Visible = bh
                aX.container.Color = z
                aX.label.Position = Vector2.new(aX.containerPos.x + 15, aX.containerPos.y + aX.containerSize.y / 2 - 7)
                aX.label.Visible = bh
                local bj = aX.containerPos.x + aX.containerSize.x - aX.previewBoxSize - 15
                local bk = aX.containerPos.y + (aX.containerSize.y - aX.previewBoxSize) / 2
                aX.previewBox.Position = Vector2.new(bj, bk)
                aX.previewBox.Size = Vector2.new(aX.previewBoxSize, aX.previewBoxSize)
                aX.previewBox.Visible = bh
                if bh then
                    local ce =
                        j.x >= bj and j.x <= bj + aX.previewBoxSize and j.y >= bk and j.y <= bk + aX.previewBoxSize
                    if ce and H then
                        if not aX.isOpen then
                            self:CloseAllDropdownsAndColorPickers()
                            aX.isOpen = true
                        else
                            aX.isOpen = false
                        end
                    elseif
                        H and aX.isOpen and
                            not (j.x >= aX.pickerPos.x and j.x <= aX.pickerPos.x + aX.pickerWidth and
                                j.y >= aX.pickerPos.y and
                                j.y <= aX.pickerPos.y + aX.pickerHeight)
                     then
                        aX.isOpen = false
                    end
                    aX:UpdateColorPicker(j, bh)
                else
                    aX.isOpen = false
                    if aX.pickerContainer then
                        aX.pickerContainer.Visible = false
                    end
                    if aX.selectedColorPreview then
                        aX.selectedColorPreview.Visible = false
                    end
                    if aX.hueGradient then
                        aX.hueGradient.Visible = false
                    end
                    if aX.saturationGradient then
                        aX.saturationGradient.Visible = false
                    end
                    if aX.valueGradient then
                        aX.valueGradient.Visible = false
                    end
                    if aX.titleBg then
                        aX.titleBg.Visible = false
                    end
                    if aX.titleText then
                        aX.titleText.Visible = false
                    end
                    if aX.hueSegments then
                        for bf, bH in ipairs(aX.hueSegments) do
                            bH.Visible = false
                        end
                    end
                    if aX.saturationSegments then
                        for bf, bH in ipairs(aX.saturationSegments) do
                            bH.Visible = false
                        end
                    end
                    if aX.valueSegments then
                        for bf, bH in ipairs(aX.valueSegments) do
                            bH.Visible = false
                        end
                    end
                end
            end
        end
    end
end
function UILib:Destroy()
    self.base:Remove()
    self.title:Remove()
    self.closeBox:Remove()
    self.closeLine1:Remove()
    self.closeLine2:Remove()
    self.minimizeBox:Remove()
    self.minimizeLine:Remove()
    for bf, aM in ipairs(self.tabs) do
        aM.tab:Remove()
        aM.label:Remove()
        aM.indicator:Remove()
        if aM.id then
            K[aM.id] = nil
        end
        for bf, aX in ipairs(aM.items) do
            if aX.container then
                aX.container:Remove()
            end
            if aX.type == "button" then
                aX.label:Remove()
                if aX.arrowLine1 then
                    aX.arrowLine1:Remove()
                end
                if aX.arrowLine2 then
                    aX.arrowLine2:Remove()
                end
                if aX.id then
                    J[aX.id] = nil
                end
            elseif aX.type == "toggle" then
                aX.box:Remove()
                aX.fill:Remove()
                aX.label:Remove()
            elseif aX.type == "slider" then
                aX.bar:Remove()
                aX.fill:Remove()
                aX.label:Remove()
                if aX.valueLabel then
                    aX.valueLabel:Remove()
                end
                if aX.indicator then
                    aX.indicator:Remove()
                end
            elseif aX.type == "dropdown" then
                if aX.container then
                    aX.container:Remove()
                end
                if aX.label then
                    aX.label:Remove()
                end
                if aX.previewBox then
                    aX.previewBox:Remove()
                end
                if aX.selectionText then
                    aX.selectionText:Remove()
                end
                if aX.dropdownContainer then
                    aX.dropdownContainer:Remove()
                end
                if aX.titleBg then
                    aX.titleBg:Remove()
                end
                if aX.titleText then
                    aX.titleText:Remove()
                end
                if aX.options then
                    for bf, bi in ipairs(aX.options) do
                        if bi.background then
                            bi.background:Remove()
                        end
                        if bi.label then
                            bi.label:Remove()
                        end
                    end
                end
                if aX.id then
                    J[aX.id] = nil
                end
            elseif aX.type == "textbox" then
                aX.container:Remove()
                aX.label:Remove()
                aX.inputBox:Remove()
                aX.inputText:Remove()
                if aX.id then
                    J[aX.id] = nil
                end
            elseif aX.type == "colorpicker" then
                if aX.Destroy then
                    aX:Destroy()
                else
                    if aX.container then
                        aX.container:Remove()
                    end
                    if aX.label then
                        aX.label:Remove()
                    end
                    if aX.previewBox then
                        aX.previewBox:Remove()
                    end
                    if aX.pickerContainer then
                        aX.pickerContainer:Remove()
                    end
                    if aX.selectedColorPreview then
                        aX.selectedColorPreview:Remove()
                    end
                    if aX.hueGradient then
                        aX.hueGradient:Remove()
                    end
                    if aX.valueGradient then
                        aX.valueGradient:Remove()
                    end
                    if aX.titleBg then
                        aX.titleBg:Remove()
                    end
                    if aX.titleText then
                        aX.titleText:Remove()
                    end
                    if aX.hueSegments then
                        for bf, bH in ipairs(aX.hueSegments) do
                            bH:Remove()
                        end
                    end
                    if aX.valueSegments then
                        for bf, bH in ipairs(aX.valueSegments) do
                            bH:Remove()
                        end
                    end
                end
                if aX.id then
                    J[aX.id] = nil
                end
            end
        end
    end
    self.tabs = {}
    self.activeTab = nil
    J = {}
    K = {}
end
function UILib:Notify(aI)
    local cl = 250
    local cm = 80
    local cn = 10
    local co = 5
    local cp = 10
    local bo = 70
    local cq = bo
    for bf, cr in ipairs(self.notifications) do
        cq = cq + cm + co + cp
    end
    local aT = Drawing.new("Square")
    aT.Size = Vector2.new(cl, cm + co)
    aT.Position = Vector2.new(20, bo)
    aT.Filled = true
    aT.Color = x
    aT.Visible = true
    aT.Corner = 7
    aT.ZIndex = 50
    local cs = Drawing.new("Text")
    cs.Text = aI.Title or "Notification"
    cs.Position = Vector2.new(20 + cn, bo + cn)
    cs.Color = y
    cs.Visible = true
    cs.ZIndex = 51
    local ct = Drawing.new("Text")
    ct.Text = aI.Content or ""
    ct.Position = Vector2.new(20 + cn, bo + cn + 20)
    ct.Color = A
    ct.Visible = true
    ct.ZIndex = 51
    local cu = Drawing.new("Square")
    cu.Size = Vector2.new(cl, co)
    cu.Position = Vector2.new(20, bo + cm)
    cu.Filled = true
    cu.Color = Color3.fromRGB(40, 40, 40)
    cu.Visible = true
    cu.Corner = 5
    cu.ZIndex = 51
    local cv = Drawing.new("Square")
    cv.Size = Vector2.new(cl, co)
    cv.Position = Vector2.new(20, bo + cm)
    cv.Filled = true
    cv.Color = y
    cv.Visible = true
    cv.Corner = 5
    cv.ZIndex = 52
    local cw = {
        container = aT,
        title = cs,
        content = ct,
        progressBg = cu,
        progressFill = cv,
        startTime = os.clock(),
        duration = aI.Duration or 5,
        fadeStart = (aI.Duration or 5) - 0.5,
        targetY = cq
    }
    table.insert(self.notifications, 1, cw)
end
function UILib:UpdateNotifications()
    local bo = 70
    local cp = 10
    local cx = 85
    local Q = 1
    while Q <= #self.notifications do
        local cy = self.notifications[Q]
        local cz = os.clock() - cy.startTime
        local cA = bo + (Q - 1) * (cx + cp)
        local cB = cA
        if cy.container and cy.container.Position then
            cB = cy.container.Position.y
        end
        local cC = cB + (cA - cB) * 0.2
        if cy.container then
            cy.container.Position = Vector2.new(20, cC)
        end
        if cy.title then
            cy.title.Position = Vector2.new(20 + 10, cC + 10)
        end
        if cy.content then
            cy.content.Position = Vector2.new(20 + 10, cC + 30)
        end
        if cy.progressBg then
            cy.progressBg.Position = Vector2.new(20, cC + 80)
        end
        if cy.progressFill then
            cy.progressFill.Position = Vector2.new(20, cC + 80)
        end
        if cz >= cy.duration then
            if cy.container then
                cy.container:Remove()
            end
            if cy.title then
                cy.title:Remove()
            end
            if cy.content then
                cy.content:Remove()
            end
            if cy.progressBg then
                cy.progressBg:Remove()
            end
            if cy.progressFill then
                cy.progressFill:Remove()
            end
            table.remove(self.notifications, Q)
        else
            local cD = 1 - cz / cy.duration
            local cE = 250 * cD
            if cy.progressFill then
                cy.progressFill.Size = Vector2.new(cE, 5)
            end
            if cz >= cy.fadeStart then
                local cF = 1 - (cz - cy.fadeStart) / (cy.duration - cy.fadeStart)
                if cy.container then
                    cy.container.Transparency = cF
                end
                if cy.title then
                    cy.title.Transparency = cF
                end
                if cy.content then
                    cy.content.Transparency = cF
                end
                if cy.progressBg then
                    cy.progressBg.Transparency = cF
                end
                if cy.progressFill then
                    cy.progressFill.Transparency = cF
                end
            end
            Q = Q + 1
        end
    end
end
function UILib:CloseAllDropdownsAndColorPickers()
    for bf, aM in ipairs(self.tabs) do
        for bf, aX in ipairs(aM.items) do
            if aX.type == "dropdown" or aX.type == "colorpicker" then
                aX.isOpen = false
                if aX.dropdownContainer then
                    aX.dropdownContainer.Visible = false
                end
                if aX.titleBg then
                    aX.titleBg.Visible = false
                end
                if aX.titleText then
                    aX.titleText.Visible = false
                end
                if aX.pickerContainer then
                    aX.pickerContainer.Visible = false
                end
                if aX.selectedColorPreview then
                    aX.selectedColorPreview.Visible = false
                end
                if aX.hueGradient then
                    aX.hueGradient.Visible = false
                end
                if aX.saturationGradient then
                    aX.saturationGradient.Visible = false
                end
                if aX.valueGradient then
                    aX.valueGradient.Visible = false
                end
                if aX.hueSegments then
                    for bf, bH in ipairs(aX.hueSegments) do
                        bH.Visible = false
                    end
                end
                if aX.saturationSegments then
                    for bf, bH in ipairs(aX.saturationSegments) do
                        bH.Visible = false
                    end
                end
                if aX.valueSegments then
                    for bf, bH in ipairs(aX.valueSegments) do
                        bH.Visible = false
                    end
                end
                if aX.options then
                    for bf, bi in ipairs(aX.options) do
                        bi.background.Visible = false
                        bi.label.Visible = false
                    end
                end
            end
        end
    end
end
ESPLib = {}
ESPLib.__index = ESPLib
RED = Color3.fromRGB(255, 0, 0)
GREEN = Color3.fromRGB(0, 255, 0)
BLUE = Color3.fromRGB(0, 0, 255)
YELLOW = Color3.fromRGB(255, 255, 0)
CYAN = Color3.fromRGB(0, 255, 255)
PINK = Color3.fromRGB(255, 0, 255)
WHITE = Color3.fromRGB(255, 255, 255)
BLACK = Color3.fromRGB(0, 0, 0)
ESP_FONTSIZE = 7
DEFAULT_PARTS_SIZING = {
    Head = Vector3.new(2, 1, 1),
    Torso = Vector3.new(2, 2, 1),
    ["Left Arm"] = Vector3.new(1, 2, 1),
    ["Right Arm"] = Vector3.new(1, 2, 1),
    ["Left Leg"] = Vector3.new(1, 2, 1),
    ["Right Leg"] = Vector3.new(1, 2, 1),
    UpperTorso = Vector3.new(2, 1, 1),
    LowerTorso = Vector3.new(2, 1, 1),
    LeftUpperArm = Vector3.new(1, 1, 1),
    LeftLowerArm = Vector3.new(1, 1, 1),
    LeftHand = Vector3.new(0.3, 0.3, 1),
    RightUpperArm = Vector3.new(1, 1, 1),
    RightLowerArm = Vector3.new(1, 1, 1),
    RightHand = Vector3.new(0.3, 0.3, 1),
    LeftUpperLeg = Vector3.new(1, 1, 1),
    LeftLowerLeg = Vector3.new(1, 1, 1),
    LeftFoot = Vector3.new(0.3, 0.3, 1),
    RightUpperLeg = Vector3.new(1, 1, 1),
    RightLowerLeg = Vector3.new(1, 1, 1),
    RightFoot = Vector3.new(0.3, 0.3, 1)
}
local cG = workspace.CurrentCamera
local function cH(cI)
    return math.sqrt(cI.x * cI.x + cI.y * cI.y + cI.z * cI.z)
end
local function cJ(cI)
    local cK = cH(cI)
    if cK == 0 then
        return Vector3.new(0, 0, 0)
    end
    return Vector3.new(cI.x / cK, cI.y / cK, cI.z / cK)
end
local function cL(cI, cM)
    local ax = math.sin(cM)
    local cN = math.cos(cM)
    return Vector3.new(cI.x * ax - cI.z * cN, 0, cI.x * cN + cI.z * ax)
end
local function cO(cP)
    for bf, cQ in ipairs(cP) do
        cQ:Remove()
    end
end
local function cR(cP)
    for bf, cQ in ipairs(cP) do
        cQ.Visible = false
    end
end
function ESPLib.new(cS)
    local self = setmetatable({}, ESPLib)
    self._objects = {}
    self._objectContainer = nil
    self._objectContainerLength = -1
    self._containerLastUpdate = 0
    self._components = {bbox = true, name = true, distance = true, flags = cS.Flags ~= nil, snapline = false}
    self._running = true
    self._gb_accent = cS.Accent or WHITE
    self._gb_distance = cS.MaxDistance or nil
    self._gb_mode = cS.Mode or ESPLib.Mode["Standard"]
    self._gb_validateEntry = cS.ValidateEntry or nil
    self._gb_fetchEntryName = cS.FetchEntryName or nil
    self._gb_traverseEntry = cS.TraverseEntry or nil
    self._gb_measureEntry = cS.MeasureEntry or nil
    self._gb_isEntryLocal = cS.IsEntryLocal or nil
    self._gb_flags = cS.Flags or nil
    return self
end
ESPLib.Component = {
    ["Box"] = "bbox",
    ["Name"] = "name",
    ["Distance"] = "distance",
    ["Flags"] = "flags",
    ["Snapline"] = "snapline"
}
ESPLib.Mode = {["Critical"] = 0, ["Standard"] = 1, ["Lazy"] = nil}
ESPLib.Validation = {["Matching Name"] = function(cT)
        return function(entry)
            return entry.Name:lower():find(cT:lower()) ~= nil
        end
    end}
function ESPLib._IsBasePart(cU)
    return cU.ClassName:lower():find("part") ~= nil
end
function ESPLib._GetTextBounds(cV)
    return #cV * ESP_FONTSIZE, ESP_FONTSIZE
end
function ESPLib:_DistanceFromLocal(cW)
    if not self._IsBasePart(cW) then
        cW = cW:FindFirstChildOfClass("Part") or cW:FindFirstChildOfClass("MeshPart")
    end
    if cW == nil then
        return 0
    end
    local cX = cW.Position
    return cH(cG.Position + Vector3.new(-cX.x, -cX.y, -cX.z))
end
function ESPLib:_BoundingBox(cY)
    local cZ, c_, d0, d1 = 0, 0, 0, 0
    local d2 = self._IsBasePart(cY) and {cY} or cY:GetChildren()
    local d3 = cG.Position
    local d4 = #d2 > 0
    for bf, d5 in ipairs(d2) do
        local d6 = d5.Name
        if d4 and self._IsBasePart(d5) then
            local d7 = d5.Position
            local d8 =
                self._gb_measureEntry and self._gb_measureEntry(cY) or
                (DEFAULT_PARTS_SIZING[d6] ~= nil and DEFAULT_PARTS_SIZING[d6] or Vector3.new(1, 1, 1))
            local d9 = cJ(Vector3.new(d7.x - d3.x, 0, d7.z - d3.z))
            local cM = math.atan2(d9.x, d9.z)
            local da = Vector3.new(d8.x / 2, d8.y / 2, d8.z / 2)
            local db =
                math.abs(cH(d8)) < 0.2 and {d7} or
                {
                    d7 + cL(Vector3.new(-da.x, 0, -da.z), cM) + Vector3.new(0, da.y, 0),
                    d7 + cL(Vector3.new(da.x, 0, da.z), cM) + Vector3.new(0, -da.y, 0)
                }
            for bf, dc in ipairs(db) do
                local dd, de = WorldToScreen(dc)
                if not de and d4 then
                    d4 = false
                elseif d4 then
                    cZ = cZ == 0 and dd.x or math.min(cZ, dd.x)
                    c_ = c_ == 0 and dd.y or math.min(c_, dd.y)
                    d0 = math.max(d0, dd.x)
                    d1 = math.max(d1, dd.y)
                end
            end
        elseif d4 and d5.ClassName == "Model" or d5.ClassName == "Folder" then
            local bf, df, dg, dh, di = self:_BoundingBox(d5)
            cZ = cZ == 0 and df or math.min(cZ, df)
            c_ = c_ == 0 and dg or math.min(c_, dg)
            d0 = math.max(d0, df + dh)
            d1 = math.max(d1, dg + di)
        end
    end
    return d4 and cZ > 0, cZ, c_, d0 - cZ, d1 - c_
end
function ESPLib:Toggle(state)
    self._running = type(state) == "boolean" and state or not self._running
end
function ESPLib:ToggleComponent(dj, state)
    local dk = self._components[dj]
    if dk ~= nil then
        self._components[dj] = type(state) == "boolean" and state or not dk
    end
end
function ESPLib:SetMaxDistance(dl)
    self._gb_distance = tonumber(dl) or nil
end
function ESPLib:SetAccent(dm)
    self._gb_accent = dm or WHITE
end
function ESPLib:SetGroupContainer(aT)
    self._objectContainer = aT
end
function ESPLib:Add(entry)
    local dn = Drawing.new("Square")
    dn.Thickness = 1
    dn.Filled = false
    local dp = Drawing.new("Square")
    dp.Thickness = 1
    dp.Filled = false
    local dq = Drawing.new("Square")
    dq.Thickness = 1
    dq.Filled = false
    local dr = Drawing.new("Line")
    dr.Thickness = 1
    local ds = Drawing.new("Text")
    ds.Outline = true
    local dt = Drawing.new("Text")
    dt.Outline = true
    local du = {}
    if self._gb_flags then
        for bf, bf in pairs(self._gb_flags) do
            local dv = Drawing.new("Text")
            dv.Outline = true
            dv.Color = Color3.fromRGB(255, 255, 255)
            table.insert(du, dv)
        end
    end
    self._objects[entry] = {["class"] = entry.ClassName, ["_drawings"] = {dn, dp, dq, ds, dt, dr, unpack(du)}}
    return entry
end
function ESPLib:Unadd(entry)
    if self._objects[entry] then
        cO(self._objects[entry]["_drawings"])
        self._objects[entry] = nil
    end
end
function ESPLib:Clear()
    for entry, bf in pairs(self._objects) do
        self:Unadd(entry)
    end
end
function ESPLib:Step()
    local dw = os.clock()
    if
        self._objectContainer and
            dw - self._containerLastUpdate > (self._gb_mode and (self._gb_mode == 1 and 0 or 0.33) or 1)
     then
        local d2 = self._objectContainer:GetChildren()
        if #d2 ~= self._objectContainerLength then
            self:Clear()
            self._objectContainerLength = #d2
            for bf, d5 in ipairs(d2) do
                if self._gb_validateEntry == nil or self._gb_validateEntry and self._gb_validateEntry(d5) == true then
                    self:Add(d5)
                end
            end
        end
        self._containerLastUpdate = dw
    end
    for cW, dx in pairs(self._objects) do
        local dy = dx["_drawings"]
        local dz = self._running
        if cW == nil then
            self:Unadd(cW)
            dz = false
        end
        if dz and self._gb_validateEntry then
            dz = self._gb_validateEntry(cW)
        end
        local dA = dz and (self._gb_traverseEntry and self._gb_traverseEntry(cW) or cW) or nil
        local dl = 0
        local de, dB, dC, dD, dE = false, 0, 0, 0, 0
        if dz and dA then
            dl = math.floor(self:_DistanceFromLocal(dA))
            if self._gb_distance == nil or self._gb_distance ~= nil and dl <= self._gb_distance then
                de, dB, dC, dD, dE = self:_BoundingBox(dA)
            else
                dz = false
            end
        end
        if de and dz and cW then
            local dF = tostring(cW.Name)
            if self._gb_fetchEntryName then
                dF = self._gb_fetchEntryName(cW)
            end
            local dG = type(self._gb_accent) == "function" and self._gb_accent(cW) or self._gb_accent
            local dn = dy[1]
            local dp = dy[2]
            local dq = dy[3]
            if self._components["bbox"] == true then
                dp.Position = Vector2.new(dB + 1, dC + 1)
                dp.Size = Vector2.new(dD - 2, dE - 2)
                dp.Color = BLACK
                dp.Visible = true
                dq.Position = Vector2.new(dB - 1, dC - 1)
                dq.Size = Vector2.new(dD + 2, dE + 2)
                dq.Color = BLACK
                dq.Visible = true
                dn.Position = Vector2.new(dB, dC)
                dn.Size = Vector2.new(dD, dE)
                dn.Color = dG
                dn.Visible = true
            else
                dn.Visible = false
                dp.Visible = false
                dq.Visible = false
            end
            local ds = dy[4]
            if self._components["name"] then
                local dH, dI = self._GetTextBounds(dF)
                ds.Position = Vector2.new(dB - dH / 2 + dD / 2, dC - dI - 6)
                ds.Color = WHITE
                ds.Text = dF
                ds.Visible = true
            else
                ds.Visible = false
            end
            local dt = dy[5]
            if self._components["distance"] then
                local dJ = "[" .. tostring(dl) .. "m]"
                local dK, dL = self._GetTextBounds(dJ)
                dt.Position = Vector2.new(dB - dK / 2 + dD / 2, dC + dE + 2)
                dt.Color = WHITE
                dt.Text = dJ
                dt.Visible = true
            else
                dt.Visible = false
            end
            local dr = dy[6]
            if self._components["snapline"] then
                dr.From = Vector2.new(0, 0)
                dr.To = Vector2.new(dB + dD / 2, dC)
                dr.Color = dG
                dr.Visible = true
            else
                dr.Visible = false
            end
            if self._gb_flags and self._components["flags"] then
                local dM = 0
                local bf, dN = self._GetTextBounds("")
                local Q = 0
                for dO, dP in pairs(self._gb_flags) do
                    Q = Q + 1
                    local dQ = dy[6 + Q]
                    local dR = dP(cW)
                    if dR == true then
                        dR = "*" .. dO .. "*"
                    elseif dR == false or dR == "" then
                        dR = nil
                    elseif dR ~= nil then
                        dR = tostring(dR)
                    end
                    if dR then
                        dQ.Position = Vector2.new(dB + dD + 2, dC + dM)
                        dQ.Text = dR
                        dQ.Visible = true
                        dM = dM + dN + 4
                    else
                        dQ.Visible = false
                    end
                end
            end
        elseif cW ~= nil then
            cR(dy)
        end
    end
end
function ESPLib:Destroy()
    self:Toggle(false)
    self:Clear()
end
AimbotLib = {}
AimbotLib.__index = AimbotLib
local dS = game:GetService("Players")
local dT = dS.LocalPlayer
local b = dT:GetMouse()
local function dU(dV, dW)
    if not dV or not dW then
        return math.huge
    end
    local dX = dV.X + -dW.X
    local dY = dV.Y + -dW.Y
    local dZ = dV.Z + -dW.Z
    return math.sqrt(dX * dX + dY * dY + dZ * dZ)
end
local function d_()
    return Vector2.new(b.X, b.Y)
end
local function e0(e1, e2, j)
    local dd, e3 = WorldToScreen(e1)
    if not e3 then
        return false
    end
    local dX = dd.X - j.X
    local dY = dd.Y - j.Y
    return dX * dX + dY * dY <= e2 * e2
end
function AimbotLib.new(e4)
    local self = setmetatable({}, AimbotLib)
    self._aimbot_key = e4.aimbot_key or 0x02
    self._fov_radius = e4.fov_radius or 40
    self._max_distance = e4.max_distance or 700
    self._validate_entry = e4.ValidateEntry
    self._traverse_entry = e4.TraverseEntry
    self._running = true
    self._fov_visible = true
    self._targets = {}
    self._target_container = nil
    self._container_length = -1
    self._last_update = 0
    self._last_target = nil
    self._fov_circle = Drawing.new("Circle")
    self._fov_circle.Visible = true
    self._fov_circle.Filled = false
    self._fov_circle.Color = Color3.fromRGB(255, 255, 255)
    self._fov_circle.Thickness = 1
    self._fov_circle.Radius = self._fov_radius
    self._fov_circle.NumSides = 80
    self._fov_circle.ZIndex = 3
    return self
end
function AimbotLib:SetTargetPath(aT)
    self._target_container = aT
end
function AimbotLib:Add(e5)
    self._targets[e5] = true
    return e5
end
function AimbotLib:Remove(e5)
    if self._targets[e5] then
        self._targets[e5] = nil
    end
end
function AimbotLib:Toggle(state)
    self._running = type(state) == "boolean" and state or not self._running
end
function AimbotLib:FovToggle(state)
    self._fov_visible = type(state) == "boolean" and state or not self._fov_visible
    if self._fov_circle then
        self._fov_circle.Visible = self._fov_visible
    end
end
function AimbotLib:SetMaxDistance(dl)
    self._max_distance = dl or 700
end
function AimbotLib:SetFov(e6)
    self._fov_radius = e6
    if self._fov_circle then
        self._fov_circle.Radius = e6
    end
end
function AimbotLib:Update()
    local j = d_()
    if self._fov_visible then
        self._fov_circle.Position = j
    end
    if not self._running then
        return
    end
    if self._target_container then
        local d2 = self._target_container:GetChildren()
        self._targets = {}
        for bf, d5 in pairs(d2) do
            if not self._validate_entry or self._validate_entry(d5) then
                self:Add(d5)
            end
        end
    end
    local e7 = dT.Character
    local e8 = e7 and e7:FindFirstChild("HumanoidRootPart")
    if not e8 then
        return
    end
    local e9 = nil
    local ea = math.huge
    for eb, bf in pairs(self._targets) do
        if eb then
            local ec = self._traverse_entry and self._traverse_entry(eb) or eb
            if ec and ec.Position then
                local ed = dU(e8.Position, ec.Position)
                if ed <= self._max_distance and e0(ec.Position, self._fov_radius, j) then
                    if ed < ea then
                        ea = ed
                        e9 = ec
                    end
                end
            end
        end
    end
    if e9 and iskeypressed(self._aimbot_key) then
        workspace.CurrentCamera.lookAt(workspace.CurrentCamera.Position, e9.Position)
    end
end
function AimbotLib:Destroy()
    self:Toggle(false)
    if self._fov_circle then
        self._fov_circle:Remove()
    end
    self._targets = {}
end
local ee =
    loadstring(
    game:HttpGet("https://raw.githubusercontent.com/MildilyAcidic/MLua/refs/heads/main/TweenService.lua", true)
)()
local ef = 66654135
local eg = 6504986360
local eh = 111958650
local ei = 115797356
local ej = 4777817887
local ek = 2101149508
local el = 6331902150
local em = 7018190066
local en = 1315961587
local eo = 7436755782
local ep = 210851291
local eq = 372226183
local er = 16680835
local es = 903807016
local et = 5286749994
local eu = 504035427
local ev = 962862716
local ew = 2440500124
local ex = 44636121
local ey = 994732206
local ez = 7326934954
local eA = 1390601379
if game.GameId == eg then
    local workspace = game:GetService("Workspace")
    local dS = game:GetService("Players")
    local a = dS.LocalPlayer
    local eB = a.Character
    local eC = eB:FindFirstChild("HumanoidRootPart")
    local eD =
        UILib:CreateWindow(
        {Name = "bubble gum simulator | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"}
    )
    eD:Notify({Title = "Loaded Script", Content = "discord.gg/5eQhEPZ4yJ", Duration = 6.5})
    local eE = eD:CreateTab("Autofarm")
    local eF = eD:CreateTab("test")
    local eG = eD:CreateTab("Gui Settings")
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                eD.toggleKey = eH
            end
        }
    )
    eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                eD:Destroy()
            end}
    )
    eF:CreateButton(
        {Name = "print player pos", Callback = function()
                print(game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame)
            end}
    )
    local eI = false
    local eJ = false
    local eK = nil
    local eL = nil
    local eM = nil
    local eN = 50
    local eO = 0
    local eP = 0
    local eQ = {
        Vector3.new(9899.73, 20089.08, 221.29),
        Vector3.new(9863.61, 20089.08, 225.15),
        Vector3.new(9898.94, 20089.08, 233.42),
        Vector3.new(9863.48, 20089.08, 233.90),
        Vector3.new(9899.52, 20089.08, 243.94),
        Vector3.new(9871.68, 20089.08, 248.03),
        Vector3.new(9899.27, 20089.14, 249.59)
    }
    local eR = {
        Vector3.new(41.938564, 15971.424805, 40.935322),
        Vector3.new(58.020065, 15971.424805, 28.992182),
        Vector3.new(59.790184, 15971.424805, 13.083396),
        Vector3.new(76.345741, 15971.424805, 18.473783),
        Vector3.new(78.613228, 15971.424805, 1.577753),
        Vector3.new(63.649632, 15971.424805, -2.183222),
        Vector3.new(75.400810, 15971.424805, -16.573893),
        Vector3.new(38.372841, 15971.424805, 53.711899),
        Vector3.new(35.963058, 15971.424805, 32.563404),
        Vector3.new(57.477871, 15971.424805, 40.850349),
        Vector3.new(55.946121, 15971.424805, 13.862309),
        Vector3.new(82.765205, 15971.424805, 18.416231),
        Vector3.new(89.081917, 15971.424805, -1.571867),
        Vector3.new(72.012619, 15971.424805, 6.253886),
        Vector3.new(64.943329, 15971.424805, 30.959179),
        Vector3.new(27.159115, 15971.424805, 45.410755),
        Vector3.new(35.632046, 15971.424805, 29.728159),
        Vector3.new(44.187519, 15971.424805, 23.117653),
        Vector3.new(54.556713, 15971.424805, 10.788894),
        Vector3.new(56.471931, 15971.393555, -6.225338),
        Vector3.new(63.877087, 15971.424805, -18.845392),
        Vector3.new(78.686745, 15971.421875, -24.233608),
        Vector3.new(90.314888, 15971.424805, -12.892670),
        Vector3.new(92.259590, 15971.424805, 1.375635),
        Vector3.new(91.273186, 15971.424805, 12.749871),
        Vector3.new(82.516418, 15973.170898, 25.403307),
        Vector3.new(77.767570, 15971.541992, 26.142542),
        Vector3.new(68.148514, 15971.424805, 25.554209),
        Vector3.new(65.690109, 15971.424805, 32.170185),
        Vector3.new(53.545403, 15971.424805, 38.804401),
        Vector3.new(30.405230, 15971.424805, 43.032291),
        Vector3.new(38.417923, 15971.424805, 31.396299),
        Vector3.new(47.183414, 15971.424805, 36.608578),
        Vector3.new(56.139149, 15971.424805, 24.203299),
        Vector3.new(58.828590, 15971.424805, 15.076225),
        Vector3.new(67.955437, 15971.424805, 9.225442),
        Vector3.new(77.914284, 15971.422852, -6.076915),
        Vector3.new(67.174118, 15971.424805, -7.490893),
        Vector3.new(62.214684, 15971.424805, 5.215615)
    }
    local eS = 1
    local function eT(eU, aB, bW)
        return eU + (aB - eU) * bW
    end
    local function eV(eW)
        local av = tostring(eW)
        local ax, cN, eX = av:match("Vector3%(([^,]+), ([^,]+), ([^)]+)%)")
        return tonumber(ax), tonumber(cN), tonumber(eX)
    end
    local function eY(eZ, e_, f0, f1, f2, f3)
        return math.sqrt((f1 - eZ) ^ 2 + (f2 - e_) ^ 2 + (f3 - f0) ^ 2)
    end
    local function dU(cI)
        return math.sqrt(cI.x * cI.x + cI.y * cI.y + cI.z * cI.z)
    end
    local function f4()
        local f5 = {}
        local f6 = workspace.Worlds["The Overworld"].Islands.Zen.Island.Pickups
        for bf, f7 in pairs(f6:GetChildren()) do
            if f7:IsA("Folder") then
                for bf, f8 in pairs(f7:GetChildren()) do
                    if f8:IsA("Part") or f8:IsA("MeshPart") then
                        table.insert(f5, f8)
                    elseif f8:IsA("Model") and f8.PrimaryPart then
                        table.insert(f5, f8.PrimaryPart)
                    end
                end
            end
        end
        return f5
    end
    local function f9()
        if not eC then
            return
        end
        local fa = nil
        if eI then
            if eS > #eQ then
                eS = 1
            end
            fa = eQ[eS]
        end
        if eJ then
            if eS > #eR then
                eS = 1
            end
            fa = eR[eS]
        end
        eS = eS + 1
        if fa then
            local dl = dU(eC.Position - fa)
            eK = eC
            eL = eC.Position
            eM = fa
            eO = dl / eN
            eP = 0
        end
    end
    eE:CreateToggle(
        {Name = "World 1 Farm", CurrentValue = false, Callback = function(fb)
                eJ = state
                if eJ then
                    eI = false
                    eS = 1
                    f9()
                end
            end}
    )
    eE:CreateToggle(
        {Name = "World 2 Farm", CurrentValue = false, Callback = function(state)
                eI = state
                if eI then
                    eJ = false
                    eS = 1
                    f9()
                end
            end}
    )
    eE:CreateSlider(
        {Name = "Tween speed", Range = {10, 200}, Increment = 10, CurrentValue = eN, Callback = function(fc)
                eN = fc
            end}
    )
    local fd = os.clock()
    while true do
        local dw = os.clock()
        local fe = dw - fd
        fd = dw
        eD:Step()
        if (eI or eJ) and eK then
            eP = eP + fe
            local bW = math.min(eP / eO, 1)
            local ff = eL + (eM - eL) * bW
            eK.Position = ff
            if bW >= 1 then
                f9()
            end
        end
        wait(0.001)
    end
elseif game.GameId == ej then
    local workspace = game:GetService("Workspace")
    local dS = game:GetService("Players")
    local a = dS.LocalPlayer
    local e7 = a.Character
    local fg = workspace:FindFirstChild("Balls")
    local fh = 30
    local fi = false
    local fj = false
    local fk = false
    local fl = false
    local fm = false
    local fn = true
    local fo = 1
    local fp = {}
    local fq = 100
    local fr = Drawing.new("Circle")
    fr.Filled = true
    fr.Radius = 10
    fr.NumSides = 25
    fr.Visible = false
    fr.Color = Color3.fromRGB(255, 255, 0)
    for Q = 1, fq do
        local fs = Drawing.new("Line")
        fs.Thickness = 3
        fs.Visible = false
        table.insert(fp, fs)
    end
    function getBall()
        if not fg then
            return nil
        end
        for bf, f8 in ipairs(fg:GetChildren()) do
            if f8:IsA("Part") and f8:GetAttribute("realBall") then
                return f8
            end
        end
        return nil
    end
    local function dU(cI)
        return math.sqrt(cI.x * cI.x + cI.y * cI.y + cI.z * cI.z)
    end
    function isTargetting(e7)
        if not fl then
            return false
        end
        return e7 and e7:FindFirstChild("Highlight") ~= nil
    end
    function parry()
        if isrbxactive then
            keypress(0x46)
            keyrelease(0x46)
        end
    end
    function drawRange(ft, fu, fv)
        if fj then
            for Q = 1, fq do
                local fw = 2 * math.pi * Q / fq
                local fx = 2 * math.pi * (Q % fq + 1) / fq
                if not ft then
                    ft = Vector3.Vector3.new(0, 0, 0)
                end
                local fy = ft + Vector3.new(math.cos(fw) * fv, 0, math.sin(fw) * fv)
                local fz = ft + Vector3.new(math.cos(fx) * fv, 0, math.sin(fx) * fv)
                local fA, fB = WorldToScreen(fy)
                local fC, fD = WorldToScreen(fz)
                if fB and fD then
                    fp[Q].Color = fu
                    fp[Q].From = fA
                    fp[Q].To = fC
                    fp[Q].Visible = true
                else
                    fp[Q].Visible = false
                end
            end
        else
            for Q = 1, fq do
                fp[Q].Visible = false
            end
        end
    end
    local fE =
        UILib:CreateWindow({Name = "Blade ball | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    fE:Notify({Title = "Loaded Script", Content = "discord.gg/5eQhEPZ4yJ", Duration = 6.5})
    local fF = fE:CreateTab("AutoParry")
    local fG = fE:CreateTab("Misc")
    local eG = fE:CreateTab("Gui Settings")
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                fE.toggleKey = eH
            end
        }
    )
    eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                fE:Destroy()
                fp:Remove()
            end}
    )
    fF:CreateToggle(
        {Name = "AutoParry", CurrentValue = false, Callback = function(state)
                fl = state
            end}
    )
    fF:CreateToggle(
        {
            Name = "Prediction [turn on Allow UnSafe LuaU Execution is options tab in matcha]",
            CurrentValue = false,
            Callback = function(state)
                fm = state
            end
        }
    )
    fF:CreateToggle(
        {Name = "Dymanic Range", CurrentValue = false, Callback = function(state)
                fi = state
            end}
    )
    fF:CreateSlider(
        {Name = "Range", Range = {10, 100}, Increment = 1, CurrentValue = 30, Callback = function(d)
                fh = d
            end}
    )
    fF:CreateToggle(
        {Name = "Show Range", CurrentValue = false, Callback = function(state)
                fj = state
            end}
    )
    fF:CreateToggle(
        {Name = "Show Ball Position", CurrentValue = false, Callback = function(state)
                fk = state
            end}
    )
    while true do
        local fH = fh
        local e7 = a.Character
        local ft = Vector3.new(0, 0, 0)
        local eC = e7:FindFirstChild("HumanoidRootPart")
        if eC then
            ft = eC.Position
        end
        local fI = false
        local fJ = getBall()
        local fK
        local fL = Vector3.new(0, 0, 0)
        local fM = fK
        if fJ then
            fK = fJ.Position
            fL = fJ.Velocity
            fM = fK
            if fn then
                local fN =
                    game:FindFirstChild("Stats"):FindFirstChild("PerformanceStats"):FindFirstChild("Ping").Address
                local fO = memory_read("double", fN + 0xC8)
                if fm then
                    fM = fK + fL * fO / 250
                end
            end
        end
        if fi then
            fH = fh + dU(fL) / 10
        end
        if fl then
            if isTargetting(e7) and fJ then
                if fM and ft and cH(ft - fM) < fH then
                    fI = true
                    parry()
                end
            end
        end
        if fk then
            if fK then
                local fP, fQ = WorldToScreen(fM)
                if fQ then
                    fr.Position = fP
                    fr.Visible = true
                else
                    fr.Visible = false
                end
            else
                fr.Visible = false
            end
        end
        local fR = Color3.fromRGB(0, 255, 0)
        if fI then
            fR = Color3.fromRGB(255, 0, 0)
        end
        drawRange(ft, fR, fH)
        fE:Step()
        wait(0.001)
    end
elseif game.GameId == ei then
    local fS =
        UILib:CreateWindow({Name = "Counter blox | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    fS:Notify({Title = "Loaded Script", Content = "discord.gg/5eQhEPZ4yJ", Duration = 6.5})
    local fT = fS:CreateTab("Main")
    local fU = fS:CreateTab("Gun Mods")
    local eG = fS:CreateTab("Gui Settings")
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                fS.toggleKey = eH
            end
        }
    )
    eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                fS:Destroy()
            end}
    )
    local fV = "default"
    local fW =
        fT:CreateDropdown(
        {
            Name = "Esp Component - soon",
            Options = {"default", "Name", "Distance"},
            CurrentOption = {"Name"},
            MultiSelect = true,
            Callback = function(d)
                fV = d
            end
        }
    )
    local fX =
        fT:CreateButton(
        {Name = "Aplly Skin", Callback = function()
                if not fV == "default" then
                end
            end}
    )
    local fY =
        fT:CreateButton(
        {Name = "Wall Bang", Callback = function()
                local fZ = game.Workspace.Map
                local f_ = game.Workspace.Ray_Ignore
                if x and f_ then
                    fZ.Parent = f_
                end
            end}
    )
    local g0 =
        fU:CreateButton(
        {Name = "INF Ammo", Callback = function()
                for Q, R in next, game:GetService("ReplicatedStorage").Weapons:GetChildren() do
                    for bf, d in next, R:GetChildren() do
                        if d.Name == "Ammo" then
                            d.Value = -1
                        end
                    end
                end
            end}
    )
    local g1 =
        fU:CreateButton(
        {Name = "No spread", Callback = function()
                for bf, g2 in ipairs(game:GetService("ReplicatedStorage").Weapons:GetChildren()) do
                    local g3 = g2:FindFirstChild("Spread")
                    if g3 then
                        for bf, g4 in ipairs(g3:GetChildren()) do
                            g4.Value = 0
                        end
                    end
                end
            end}
    )
    local g5 =
        fU:CreateButton(
        {Name = "Rapid fire", Callback = function()
                for Q, R in next, game:GetService("ReplicatedStorage").Weapons:GetChildren() do
                    for bf, d in next, R:GetChildren() do
                        if d.Name == "FireRate" then
                            d.Value = -1
                        end
                    end
                end
            end}
    )
    local g6 =
        fU:CreateButton(
        {Name = "force Automatic", Callback = function()
                for Q, R in next, game:GetService("ReplicatedStorage").Weapons:GetChildren() do
                    for bf, d in next, R:GetChildren() do
                        if d.Name == "Automatic" then
                            d.Value = true
                        end
                    end
                end
            end}
    )
    local g7 =
        fU:CreateButton(
        {Name = "instant Kill - works???", Callback = function()
                for Q, R in next, game:GetService("ReplicatedStorage").Weapons:GetChildren() do
                    for bf, d in next, R:GetChildren() do
                        if d.Name == "DMG - maybe working?" then
                            d.Value = 100
                        end
                    end
                end
            end}
    )
    while true do
        fS:Step()
        wait(0.001)
    end
elseif game.GameId == eh then
    local dS = game:GetService("Players")
    local dT = dS.Localplayer
    local fS = UILib:CreateWindow({Name = "Arsenal | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    fS:Notify({Title = "Loaded Script", Content = "discord.gg/5eQhEPZ4yJ", Duration = 6.5})
    local g8 = fS:CreateTab("main")
    local fU = fS:CreateTab("Gun mods")
    local eG = fS:CreateTab("Gui Settings")
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                fS.toggleKey = eH
            end
        }
    )
    eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                fS:Destroy()
            end}
    )
    local g9 = false
    local ga = Vector3.new(10, 10, 10)
    local gb = 0.9
    local gc =
        g8:CreateToggle(
        {Name = "Hitbox Expander", CurrentValue = false, Callback = function(state)
                g9 = state
            end}
    )
    local gd =
        g8:CreateSlider(
        {Name = "Hitbox Size", Range = {4, 40}, Increment = 1, CurrentValue = 10, Callback = function(d)
                ga = Vector3.new(d, d, d)
            end}
    )
    local gd =
        g8:CreateSlider(
        {Name = "Hitbox Size", Range = {0, 1}, Increment = 0.01, CurrentValue = 0.9, Callback = function(d)
                gb = d
            end}
    )
    local g6 =
        fU:CreateButton(
        {Name = "force Automatic", Callback = function()
                for Q, R in next, game:GetService("ReplicatedStorage").Weapons:GetChildren() do
                    for bf, d in next, R:GetChildren() do
                        if d.Name == "Automatic" then
                            d.Value = true
                        end
                    end
                end
            end}
    )
    local g0 =
        fU:CreateButton(
        {Name = "INF Ammo", Callback = function()
                for Q, R in next, game:GetService("ReplicatedStorage").Weapons:GetChildren() do
                    for bf, d in next, R:GetChildren() do
                        if d.Name == "Ammo" then
                            d.Value = 299
                        end
                    end
                end
            end}
    )
    local ge =
        fU:CreateButton(
        {Name = "INF Stored Ammo", Callback = function()
                for Q, R in next, game:GetService("ReplicatedStorage").Weapons:GetChildren() do
                    for bf, d in next, R:GetChildren() do
                        if d.Name == "StoredAmmo" then
                            d.Value = 299
                        end
                    end
                end
            end}
    )
    local g1 =
        fU:CreateButton(
        {Name = "No spread", Callback = function()
                for Q, R in next, game:GetService("ReplicatedStorage").Weapons:GetChildren() do
                    for bf, d in next, R:GetChildren() do
                        if d.Name == "Spread" then
                            d.Value = 0
                        end
                    end
                end
            end}
    )
    local gf =
        fU:CreateButton(
        {Name = "No recoil", Callback = function()
                for Q, R in next, game:GetService("ReplicatedStorage").Weapons:GetChildren() do
                    for bf, d in next, R:GetChildren() do
                        if d.Name == "RecoilControl" then
                            d.Value = 0
                        end
                    end
                end
            end}
    )
    local g5 =
        fU:CreateButton(
        {Name = "Rapid fire", Callback = function()
                for Q, R in next, game:GetService("ReplicatedStorage").Weapons:GetChildren() do
                    for bf, d in next, R:GetChildren() do
                        if d.Name == "FireRate" then
                            d.Value = 0.01
                        end
                    end
                end
            end}
    )
    function setTransparency(gg, gh)
        if gg then
            memory_write("float", memory_read("uintptr_t", gg.Address + 0x170) + 0xF0, gh)
        end
    end
    while true do
        if g9 then
            local dS = game:GetService("Players")
            local dT = dS.LocalPlayer
            for bf, a in pairs(dS:GetChildren()) do
                if a.Address ~= dT.Address then
                    local eB = a.Character
                    if eB then
                        local eC = eB:FindFirstChild("HumanoidRootPart")
                        local gi = eB:FindFirstChild("RightUpperLeg")
                        local gj = eB:FindFirstChild("LeftUpperLeg")
                        local gk = eB:FindFirstChild("HeadHB")
                        if eC then
                            eC.Size = ga
                            setTransparency(gi, 1)
                            eC.CanCollide = false
                        end
                        if gi then
                            gi.Size = ga
                            setTransparency(gi, 1)
                            gi.CanCollide = false
                        end
                        if gj then
                            gj.Size = ga
                            setTransparency(gj, 1)
                            gj.CanCollide = false
                        end
                        if gk then
                            gk.Size = ga
                            setTransparency(gk, gb)
                            gk.CanCollide = false
                        end
                    end
                end
            end
        end
        fS:Step()
        wait(0.001)
    end
elseif game.GameId == ek then
    local gl = AimbotLib.new({aimbot_key = 0x02, fov_radius = 250, max_distance = 700})
    local fS =
        UILib:CreateWindow(
        {Name = "Reflex aim traniner | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"}
    )
    fS:Notify({Title = "Loaded Script", Content = "discord.gg/5eQhEPZ4yJ", Duration = 6.5})
    local eG = fS:CreateTab("Gui Settings")
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                fS.toggleKey = eH
            end
        }
    )
    local g8 = fS:CreateTab("aimbot")
    local gm =
        g8:CreateToggle(
        {Name = "Enable Aimbot", CurrentValue = true, Callback = function(state)
                gl:Toggle(state)
            end}
    )
    local gn =
        g8:CreateToggle(
        {Name = "Show FOV Circle", CurrentValue = true, Callback = function(state)
                gl:FovToggle(state)
            end}
    )
    local go =
        g8:CreateSlider(
        {Name = "FOV Radius", Range = {10, 800}, Increment = 5, CurrentValue = 250, Callback = function(d)
                gl:SetFov(d)
            end}
    )
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                fS.toggleKey = eH
            end
        }
    )
    gl:SetTargetPath(workspace.Targets)
    while true do
        gl:Update()
        fS:Step()
        wait(0.001)
    end
elseif game.GameId == el then
    local gp = ESPLib.new {FetchEntryName = function(entry)
            return "Killer"
        end, Accent = RED}
    local gq = ESPLib.new {FetchEntryName = function(gr)
            return "Survivors"
        end, Accent = GREEN}
    local gs = ESPLib.new {TraverseEntry = function(entry)
            return entry.Instances
        end, FetchEntryName = function(entry)
            return "Progress - " .. entry.Progress.Value .. "%"
        end, ValidateEntry = function(entry)
            return entry.Name == "Generator"
        end, Accent = YELLOW}
    local gt = ESPLib.new {FetchEntryName = function(entry)
            return "Medkit"
        end, ValidateEntry = function(entry)
            return entry.Name == "Medkit"
        end, Accent = BLUE}
    local gu = ESPLib.new {FetchEntryName = function(entry)
            return "BloxyCola"
        end, ValidateEntry = function(entry)
            return entry.Name == "BloxyCola"
        end, Accent = BLUE}
    gq:SetGroupContainer(workspace.Players.Survivors)
    gp:SetGroupContainer(workspace.Players.Killers)
    gs:SetGroupContainer(workspace.Map.Ingame.Map)
    gt:SetGroupContainer(workspace.Map.Ingame)
    gu:SetGroupContainer(workspace.Map.Ingame)
    gq:Toggle(false)
    gp:Toggle(false)
    gs:Toggle(false)
    gt:Toggle(false)
    gu:Toggle(false)
    local fS =
        UILib:CreateWindow({Name = "Forsaken (Beta) | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    fS:Notify({Title = "Loaded Script", Content = "discord.gg/5eQhEPZ4yJ", Duration = 6.5})
    local gv = fS:CreateTab("Esp")
    local eG = fS:CreateTab("Gui Settings")
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                fS.toggleKey = eH
            end
        }
    )
    eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                gq:Toggle(false)
                gp:Toggle(false)
                gs:Toggle(false)
                gt:Toggle(false)
                gu:Toggle(false)
                gs:Destroy()
                gq:Destroy()
                gp:Destroy()
                gt:Destroy()
                gu:Destroy()
                fS:Destroy()
            end}
    )
    local gw =
        gv:CreateToggle(
        {Name = "killer Esp", CurrentValue = false, Callback = function(state)
                gp:Toggle(state)
            end}
    )
    local gx =
        gv:CreateToggle(
        {Name = "survivor Esp", CurrentValue = false, Callback = function(state)
                gq:Toggle(state)
            end}
    )
    local gy =
        gv:CreateToggle(
        {Name = "Generator Esp - breaks every new round :(", CurrentValue = false, Callback = function(state)
                gs:Toggle(state)
            end}
    )
    local gz =
        gv:CreateToggle(
        {Name = "Medkit Esp", CurrentValue = false, Callback = function(state)
                gt:Toggle(state)
            end}
    )
    local gA =
        gv:CreateToggle(
        {Name = "BloxyCola Esp", CurrentValue = false, Callback = function(state)
                gu:Toggle(state)
            end}
    )
    while true do
        gp:Step()
        gq:Step()
        gs:Step()
        gt:Step()
        gu:Step()
        fS:Step()
        wait(0.001)
    end
elseif game.GameId == en then
    local gB = ESPLib.new {FetchEntryName = function(gr)
            return "Targets"
        end, Accent = RED}
    gB:SetGroupContainer(workspace.characters)
    gB:Toggle(false)
    local gl = AimbotLib.new({aimbot_key = 0x02, fov_radius = 250, max_distance = 700})
    gl:SetTargetPath(workspace.characters)
    gl:FovToggle(false)
    local fS =
        UILib:CreateWindow({Name = "Dead Line | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    fS:Notify({Title = "Loaded Script", Content = "discord.gg/5eQhEPZ4yJ", Duration = 6.5})
    local gC = fS:CreateTab("Aimbot - broken")
    local gD = fS:CreateTab("Esp")
    local eG = fS:CreateTab("Gui Settings")
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                fS.toggleKey = eH
            end
        }
    )
    eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                fS:Destroy()
                gB:Destroy()
                gl:Destroy()
            end}
    )
    local gE =
        gC:CreateToggle(
        {Name = "Aimbot - broken", CurrentValue = false, Callback = function(state)
                gl:Toggle(state)
            end}
    )
    local gF =
        gC:CreateToggle(
        {Name = "Teamcheck - broken", CurrentValue = false, Callback = function(state)
            end}
    )
    local gG =
        gC:CreateToggle(
        {Name = "Show FOV - broken", CurrentValue = false, Callback = function(state)
                gl:FovToggle(state)
            end}
    )
    local gH =
        gC:CreateSlider(
        {Name = "FOV radius", Range = {10, 500}, Increment = 1, CurrentValue = 300, Callback = function(d)
                gl:SetFov(d)
            end}
    )
    local gI =
        gD:CreateToggle(
        {Name = "Esp", CurrentValue = false, Callback = function(state)
                gB:Toggle(state)
            end}
    )
    local gJ =
        gD:CreateToggle(
        {Name = "Teamcheck - broken", CurrentValue = false, Callback = function(state)
            end}
    )
    while true do
        gl:Update()
        gB:Step()
        fS:Step()
        wait(0.001)
    end
elseif game.GameId == eo then
    local function gK()
        if AutoFarm then
            local e7 = a.Character
            if not e7 or not e7:FindFirstChild("HumanoidRootPart") then
                return
            end
            local gL = GetPlants()
            if #gL > 0 then
                local gM = gL[math.random(1, #gL)]
                if AutoFarm then
                    local gN = tick()
                    while tick() - gN < StayTime and AutoFarm do
                        e7.HumanoidRootPart.CFrame = gM.CFrame + Vector3.new(0, 3, 0)
                        keypress(0x45)
                        wait(0.05)
                        keyrelease(0x45)
                        wait(0.1)
                    end
                end
            end
        end
    end
    local fS =
        UILib:CreateWindow({Name = "Grow a Garden | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    fS:Notify({Title = "Loaded Script", Content = "discord.gg/5eQhEPZ4yJ", Duration = 6.5})
    local dS = game.Players
    local a = dS.LocalPlayer
    local gO = workspace:FindFirstChild("Farm")
    local gP
    local gL = {}
    local AutoFarm = false
    local gQ = false
    local gR = 100
    function GetCurrentFarm()
        for bf, d5 in ipairs(gO:GetChildren()) do
            if d5.Important.Data.Owner.Value == a.Name then
                return d5
            end
        end
    end
    function GetPlants()
        local gS = {}
        if gP and gP:FindFirstChild("Important") and gP.Important:FindFirstChild("Plants_Physical") then
            for bf, d5 in ipairs(gP.Important.Plants_Physical:GetDescendants()) do
                if d5.Name == "Base" then
                    table.insert(gS, d5)
                end
            end
        end
        return gS
    end
    gP = GetCurrentFarm()
    gL = GetPlants()
    local gT = fS:CreateTab("AutoFarm")
    local eG = fS:CreateTab("Gui Settings")
    gT:CreateToggle(
        {Name = "AutoFarm", CurrentValue = false, Callback = function(state)
                AutoFarm = state
                print("AutoFarm toggled:", state)
            end}
    )
    local StayTime = 2
    gT:CreateSlider(
        {
            Name = "Stay at Plant (seconds)",
            Range = {1, 10},
            Increment = 1,
            CurrentValue = StayTime,
            Callback = function(d)
                StayTime = d
            end
        }
    )
    gT:CreateToggle(
        {Name = "AutoSell", CurrentValue = false, Callback = function(state)
                gQ = state
                print("AutoSell toggled:", state)
            end}
    )
    gT:CreateSlider(
        {Name = "Max Inventory", Range = {1, 200}, Increment = 1, CurrentValue = 100, Callback = function(d)
                gR = d
                print("Max Inventory set to:", d)
            end}
    )
    gT:CreateButton(
        {Name = "Test", Callback = function()
                print("Current Farm:", gP)
                print("Found", #gL, "plants")
                for bf, gU in ipairs(gL) do
                    print(gU.Position)
                end
            end}
    )
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                fS.toggleKey = eH
            end
        }
    )
    eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                fS:Destroy()
                AutoFarm = false
            end}
    )
    while true do
        gK()
        fS:Step()
        wait(0.001)
    end
elseif game.GameId == ep then
    local gV = false
    local gW = {Vector3.new(-55, 100, 1200), Vector3.new(-55, 100, 8700), Vector3.new(-55, -350, 9500)}
    local gX = false
    local eK = nil
    local eL = nil
    local eM = nil
    local eN = 50
    local eO = 0
    local eP = 0
    local eS = 1
    local function eT(eU, aB, bW)
        return eU + (aB - eU) * bW
    end
    local function eV(eW)
        local av = tostring(eW)
        local ax, cN, eX = av:match("Vector3%(([^,]+), ([^,]+), ([^)]+)%)")
        return tonumber(ax), tonumber(cN), tonumber(eX)
    end
    local function eY(eZ, e_, f0, f1, f2, f3)
        return math.sqrt((f1 - eZ) ^ 2 + (f2 - e_) ^ 2 + (f3 - f0) ^ 2)
    end
    local function f9()
        local e7 = game.Players.LocalPlayer.Character
        local eC = e7 and e7:FindFirstChild("HumanoidRootPart")
        if not eC then
            return
        end
        if eS > #gW then
            eS = 1
        end
        local fa = gW[eS]
        eS = eS + 1
        if fa then
            local gY, gZ, g_ = eV(eC.Position)
            local h0, h1, h2 = eV(fa)
            local dl = eY(gY, gZ, g_, h0, h1, h2)
            eK = eC
            eL = {gY, gZ, g_}
            eM = {h0, h1, h2}
            eO = dl / eN
            eP = 0
        end
    end
    local fS =
        UILib:CreateWindow(
        {Name = "Build a boat for treasure | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"}
    )
    fS:Notify({Title = "Loaded Script", Content = "discord.gg/5eQhEPZ4yJ", Duration = 6.5})
    local gT = fS:CreateTab("AutoFarm")
    local h3 = fS:CreateTab("misc")
    local eG = fS:CreateTab("Gui Settings")
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                fS.toggleKey = eH
            end
        }
    )
    local h4 =
        gT:CreateToggle(
        {Name = "AutoFarm", CurrentValue = false, Callback = function(state)
                gV = state
                if state then
                    eS = 1
                    f9()
                end
            end}
    )
    local h5 =
        gT:CreateSlider(
        {Name = "AutoFarm Speed", Range = {10, 200}, Increment = 10, CurrentValue = eN, Callback = function(d)
                eN = d
            end}
    )
    local fd = os.clock()
    while true do
        local dw = os.clock()
        local fe = dw - fd
        fd = dw
        if gV and eK then
            eP = eP + fe
            local bW = math.min(eP / eO, 1)
            local ax = eT(eL[1], eM[1], bW)
            local cN = eT(eL[2], eM[2], bW)
            local eX = eT(eL[3], eM[3], bW)
            eK.Position = Vector3.new(ax, cN, eX)
            if bW >= 1 then
                f9()
            end
        end
        fS:Step()
        wait(0.001)
    end
elseif game.GameId == eq then
    function isBeast(entry)
        local isBeast = false
        isBeast = entry.Character:FindFirstChild("PackedHammer")
        return isBeast
    end
    local h6 = ESPLib.new {FetchEntryName = function(gr)
            return "Survivor"
        end, ValidateEntry = function(entry)
            return not isBeast(entry)
        end, TraverseEntry = function(entry)
            return entry.Character
        end, Accent = GREEN}
    h6:SetGroupContainer(game.Players)
    h6:Toggle(false)
    local h7 = ESPLib.new {FetchEntryName = function(entry)
            return "Beast"
        end, ValidateEntry = function(entry)
            return isBeast(entry)
        end, TraverseEntry = function(entry)
            return entry.Character
        end, Accent = RED}
    h7:SetGroupContainer(game.Players)
    h7:Toggle(false)
    local fS =
        UILib:CreateWindow(
        {Name = "Flee The Facility | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"}
    )
    fS:Notify({Title = "Loaded Script", Content = "discord.gg/5eQhEPZ4yJ", Duration = 6.5})
    local gv = fS:CreateTab("Esp")
    local h3 = fS:CreateTab("Misc")
    local eG = fS:CreateTab("Gui Settings")
    local h8 = fS:CreateTab("Credits")
    local h9 =
        h8:CreateButton(
        {Name = "credits to  c96h", Callback = function()
            end}
    )
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                fS.toggleKey = eH
            end
        }
    )
    local ha =
        gv:CreateToggle(
        {Name = "survivor ESP - coming soon", CurrentValue = false, Callback = function(state)
                h6:Toggle(state)
            end}
    )
    local hb =
        gv:CreateToggle(
        {Name = "Beast ESP - coming soon", CurrentValue = false, Callback = function(state)
                h7:Toggle(state)
            end}
    )
    local hc = ESPLib.new {FetchEntryName = function(gr)
            return "Computer"
        end, Accent = YELLOW, ValidateEntry = function(entry)
            return entry:IsA("Model") and (entry.Name == "ComputerTable" or entry.Name:find("Computer") ~= nil)
        end}
    hc:Toggle(false)
    local hd =
        gv:CreateToggle(
        {Name = "Computer ESP", CurrentValue = false, Callback = function(state)
                hc:Toggle(state)
            end}
    )
    local function he()
        for bf, f8 in pairs(workspace:GetChildren()) do
            if f8:IsA("Model") and f8:FindFirstChild("ComputerTable") then
                return f8
            end
        end
        return nil
    end
    local hf = he()
    if hf then
        hc:SetGroupContainer(hf)
    end
    for bf, d5 in ipairs(workspace:GetChildren()) do
        if d5:IsA("Model") and d5:FindFirstChild("ComputerTable") then
            hc:SetGroupContainer(d5)
        end
    end
    local hg =
        eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                hc:Destroy()
                fS:Destroy()
            end}
    )
    while true do
        local hf = he()
        hc:SetGroupContainer(hf)
        h6:Step()
        h7:Step()
        hc:Step()
        fS:Step()
        wait(0.001)
    end
elseif game.GameId == em then
    local hh = ESPLib.new {Accent = YELLOW, FetchEntryName = function(entry)
            return entry.Name
        end}
    hh:Toggle(false)
    hh:SetMaxDistance(700)
    hh:SetGroupContainer(workspace.RuntimeItems)
    local hi =
        UILib:CreateWindow(
        {Name = "Dead Rails - Beta | discord.gg/5eQhEPZ4yJ", Theme = "Deafault", ToggleUIKeybind = "K"}
    )
    local hj = hi:CreateTab("Esp")
    local eG = hi:CreateTab("Gui Settings")
    local hk =
        hj:CreateToggle(
        {Name = "Item ESP", CurrentValue = false, Callback = function(state)
                hh:Toggle(state)
            end}
    )
    local hl =
        hj:CreateSlider(
        {Name = "Render Distance", Range = {100, 1000}, Increment = 1, CurrentValue = 700, Callback = function(d)
                hh:SetMaxDistance(d)
            end}
    )
    local hm =
        hj:CreateDropdown(
        {
            Name = "Esp Component - soon",
            Options = {"Box", "Name", "Distance"},
            CurrentOption = {"Name"},
            MultiSelect = true,
            Callback = function(d)
                if d == "Box" then
                    hh:ToggleComponent("Box", true)
                else
                    hh:ToggleComponent("Box", false)
                end
                if d == "Name" then
                    hh:ToggleComponent("Name", true)
                else
                    hh:ToggleComponent("Name", false)
                end
                if d == "Distance" then
                    hh:ToggleComponent("Distance", true)
                else
                    hh:ToggleComponent("Distance", false)
                end
            end
        }
    )
    eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                hi.toggleKey = eH
            end
        }
    )
    local hg =
        eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                hh:Destroy()
                hi:Destroy()
            end}
    )
    while true do
        hh:Step()
        hi:Step()
        wait(0.001)
    end
    hh:Destroy()
    hi:Destroy()
elseif game.GameId == ef then
    local workspace = game:GetService("Workspace")
    local dS = game:GetService("Players")
    local a = dS.LocalPlayer
    local eB = a.Character
    local hi =
        UILib:CreateWindow(
        {Name = "Murder Mystery 2 | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"}
    )
    local eE = hi:CreateTab("Autofarm")
    local hn = hi:CreateTab("Esp")
    local eG = hi:CreateTab("Gui Settings")
    eG:CreateTextbox(
        {
            Name = "Toggle UI Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                hi.ToggleUIKeybind = eH
            end
        }
    )
    eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                hi:Destroy()
            end}
    )
    function ismurder(ho)
        local eB = ho.Character
        local hp = ho:FindFirstChildOfClass("Backpack")
        local hq = nil
        if hp then
            hq = hp:FindFirstChild("Knife")
        end
        if not hq and eB then
            hq = eB:FindFirstChild("Knife")
        end
        if hq and hq:IsA("Tool") then
            return true
        end
        return false
    end
    function issheriff(ho)
        local eB = ho.Character
        local hp = ho:FindFirstChildOfClass("Backpack")
        local hr = nil
        if hp then
            hr = hp:FindFirstChild("Gun")
        end
        if not hr and eB then
            hr = eB:FindFirstChild("Gun")
        end
        if hr and hr:IsA("Tool") then
            return true
        end
        return false
    end
    function getMap()
        for bf, d5 in ipairs(workspace:GetChildren()) do
            if d5:FindFirstChild("Spawns") then
                return d5
            end
        end
        return nil
    end
    local hs = ESPLib.new {ValidateEntry = function(entry)
            if entry.Name == "GunDrop" then
                return true
            end
            return false
        end, FetchEntryName = function(entry)
            return "Gun"
        end, Accent = YELLOW}
    hs:Toggle(false)
    hs:SetGroupContainer(workspace)
    local ht = ESPLib.new {ValidateEntry = function(entry)
            if entry and entry:FindFirstChild("Backpack") then
                local hp = entry.Backpack
                local hu = hp:FindFirstChild("Knife")
                local hv = hp:FindFirstChild("Gun")
                return not ismurder(entry) and not issheriff(entry)
            end
            return true
        end, TraverseEntry = function(entry)
            return entry.Character
        end, FetchEntryName = function(entry)
            return "Innocent"
        end, Accent = GREEN}
    ht:Toggle(false)
    ht:SetGroupContainer(game.Players)
    local hw = ESPLib.new {ValidateEntry = function(entry)
            return ismurder(entry)
        end, TraverseEntry = function(entry)
            return entry.Character
        end, FetchEntryName = function(entry)
            return "murder"
        end, Accent = RED}
    hw:Toggle(false)
    hw:SetGroupContainer(game.Players)
    local hx = ESPLib.new {ValidateEntry = function(entry)
            return issheriff(entry)
        end, TraverseEntry = function(entry)
            return entry.Character
        end, FetchEntryName = function(entry)
            return "Sheriff"
        end, Accent = BLUE}
    hx:Toggle(false)
    hx:SetGroupContainer(game.Players)
    local hy =
        hn:CreateToggle(
        {Name = "Innocent Esp", CurrentValue = false, Callback = function(state)
                ht:Toggle(state)
            end}
    )
    local hz =
        hn:CreateToggle(
        {Name = "Sheriff Esp", CurrentValue = false, Callback = function(state)
                hx:Toggle(state)
            end}
    )
    local hA =
        hn:CreateToggle(
        {Name = "Murder Esp", CurrentValue = false, Callback = function(state)
                hw:Toggle(state)
            end}
    )
    local hB =
        hn:CreateToggle(
        {Name = "Gun Drop Esp", CurrentValue = false, Callback = function(state)
                hs:Toggle(state)
            end}
    )
    local hC = false
    local hD = 20
    eE:CreateToggle(
        {Name = "Autofarm", CurrentValue = false, Callback = function(state)
                hC = state
            end}
    )
    eE:CreateSlider(
        {Name = "AutoFarm speed", Range = {1, 50}, Increment = 1, CurrentValue = 20, Callback = function(d)
                hD = d
            end}
    )
    local hE = os.clock()
    function lerpTo(hF, eb, hG, fe)
        if not hF or not eb then
            return hF, false
        end
        local dX = eb.X - hF.X
        local dY = eb.Y - hF.Y
        local dZ = eb.Z - hF.Z
        local dl = math.sqrt(dX * dX + dY * dY + dZ * dZ)
        if dl < 2 then
            return eb, true
        end
        local hH, hI, hJ = dX / dl, dY / dl, dZ / dl
        local hK = hG * fe
        if hK >= dl then
            return eb, true
        end
        local hL = Vector3.new(hF.X + hH * hK, hF.Y + hI * hK, hF.Z + hJ * hK)
        return hL, false
    end
    function dU(dV, dW)
        if not dV or not dW then
            return math.huge
        end
        local dX = dV.X + -dW.X
        local dY = dV.Y + -dW.Y
        local dZ = dV.Z + -dW.Z
        return math.sqrt(dX * dX + dY * dY + dZ * dZ)
    end
    local hM = nil
    function getClosestCoin(eC)
        local ft = eC and eC.Position or Vector3.new(0, 0, 0)
        local hN = {}
        for bf, f8 in pairs(game.Workspace:GetChildren()) do
            if f8:IsA("Model") or f8:IsA("Folder") then
                local hO = f8:FindFirstChild("CoinContainer")
                if hO then
                    for bf, hP in pairs(hO:GetChildren()) do
                        if hP:IsA("Part") and hP.Transparency == 1 then
                            table.insert(hN, hP)
                        end
                    end
                end
            end
        end
        if #hN == 0 then
            hM = nil
            return nil
        end
        local ea = math.huge
        local hQ = nil
        for bf, hP in pairs(hN) do
            local dl = dU(ft, hP.Position)
            if dl < ea and dl <= 100 then
                ea = dl
                hQ = hP
            end
        end
        if hQ then
            hM = hQ
        else
            hM = nil
        end
        return hM
    end
    function noClip(eB)
        if eB then
            for Q, R in next, eB:GetChildren() do
                if R:IsA("Part") or R:IsA("MeshPart") then
                    R.CanCollide = false
                end
            end
        end
    end
    while true do
        local aj = os.clock()
        local fe = aj - hE
        hE = aj
        dT = dS.LocalPlayer
        local e7 = dT.Character
        local eC = nil
        if e7 then
            eC = e7:FindFirstChild("HumanoidRootPart")
        end
        if hC then
            noClip(e7)
            if not hM or not hM.Positionor or not hM.Transparency == 1 then
                getClosestCoin(eC)
            end
            if eC and hM and hM.Position and game.Players.LocalPlayer:GetAttribute("Alive") then
                local hR, hS = lerpTo(eC.Position, hM.Position + Vector3.new(0, 2, 0), hD, fe)
                eC.Position = hR
                if hS then
                    hM = nil
                end
            end
        end
        getClosestCoin(eC)
        hx:Step()
        ht:Step()
        hw:Step()
        hi:Step()
        wait(0.001)
    end
elseif game.GameId == er then
    local hi =
        UILib:CreateWindow({Name = "Notoriety | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    local hT = ESPLib.new {FetchEntryName = function(entry)
            return "Citizen"
        end, Accent = YELLOW}
    hT:Toggle(false)
    hT:SetGroupContainer(workspace.Citizens)
    local hU = ESPLib.new {FetchEntryName = function(entry)
            return "Police"
        end, Accent = RED}
    hU:Toggle(false)
    hU:SetGroupContainer(workspace.Police)
    local hV = ESPLib.new {FetchEntryName = function(entry)
            return "Camera"
        end, Accent = BLUE}
    hV:Toggle(false)
    hV:SetGroupContainer(workspace.Cameras)
    local hW = ESPLib.new {FetchEntryName = function(entry)
            return "Lootable"
        end, Accent = YELLOW}
    hW:Toggle(false)
    hW:SetGroupContainer(workspace.Lootables)
    local hX = ESPLib.new {FetchEntryName = function(entry)
            return "KeyCard Reader"
        end, Accent = GREEN}
    hX:Toggle(false)
    hX:SetGroupContainer(workspace.Map.KeyCardSlots)
    local hj = hi:CreateTab("Esp")
    local eG = hi:CreateTab("Gui Settings")
    local hY =
        eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                window.toggleKey = eH
            end
        }
    )
    local hg =
        eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                hT:Destroy()
                hU:Destroy()
                hV:Destroy()
                hW:Destroy()
                hX:Destroy()
                hi:Destroy()
            end}
    )
    local hZ =
        hj:CreateToggle(
        {Name = "Citizens Esp - broken", CurrentValue = false, Callback = function(state)
                hT:Toggle(state)
            end}
    )
    local h_ =
        hj:CreateToggle(
        {Name = "Police Esp", CurrentValue = false, Callback = function(state)
                hU:Toggle(state)
            end}
    )
    local i0 =
        hj:CreateToggle(
        {Name = "Camera Esp", CurrentValue = false, Callback = function(state)
                hV:Toggle(state)
            end}
    )
    local i1 =
        hj:CreateToggle(
        {Name = "Lootables Esp - beta", CurrentValue = false, Callback = function(state)
                hW:Toggle(state)
            end}
    )
    local i2 =
        hj:CreateToggle(
        {Name = "KeyCard Reader Esp", CurrentValue = false, Callback = function(state)
                hX:Toggle(state)
            end}
    )
    while true do
        hT:Step()
        hU:Step()
        hV:Step()
        hW:Step()
        hX:Step()
        hi:Step()
        wait(0.001)
    end
elseif game.GameId == es then
    local hi = UILib:CreateWindow({Name = "ERLC | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    local h6 = ESPLib.new {TraverseEntry = function(entry)
            return entry.Character
        end, FetchEntryName = function(gr)
            return "Player"
        end, Accent = GREEN}
    local i3 = ESPLib.new {TraverseEntry = function(entry)
            return entry.Character
        end, FetchEntryName = function(entry)
            return "Wanted"
        end, Accent = RED, ValidateEntry = function(entry)
            if entry.Is_Wanted then
                return true
            end
            return false
        end}
    h6:Toggle(true)
    i3:Toggle(false)
    h6:SetGroupContainer(Players)
    i3:SetGroupContainer(Players)
    local hj = hi:CreateTab("Esp")
    local eG = hi:CreateTab("Gui Settings")
    local i4 =
        hj:CreateToggle(
        {Name = "Player Esp", CurrentValue = false, Callback = function(state)
                h6:Toggle(state)
            end}
    )
    local i5 =
        hj:CreateToggle(
        {Name = "Wanted Esp", CurrentValue = false, Callback = function(state)
                i3:Toggle(state)
            end}
    )
    while true do
        h6:Step()
        i3:Step()
        hi:Step()
        wait(0.001)
    end
elseif game.GameId == et then
    local hi =
        UILib:CreateWindow({Name = "AfterMath | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    local h6 = ESPLib.new {FetchEntryName = function(entry)
            return "Player"
        end, Accent = GREEN}
    h6:SetGroupContainer(workspace.Characters)
    local i6 = ESPLib.new {FetchEntryName = function(entry)
            return "NPC"
        end, Accent = GREEN}
    i6:SetGroupContainer(workspace.game_assets.NPCs)
    local hj = hi:CreateTab("Esp")
    local eG = hi:CreateTab("Gui Settings")
    local i4 =
        hj:CreateToggle(
        {Name = "Player Esp", CurrentValue = false, Callback = function(state)
                h6:Toggle(state)
            end}
    )
    local i7 =
        hj:CreateToggle(
        {Name = "NPC Esp", CurrentValue = false, Callback = function(state)
                i6:Toggle(state)
            end}
    )
    while true do
        i6:Step()
        hi:Step()
        wait(0.001)
    end
elseif game.GameId == eu then
    local hi =
        UILib:CreateWindow({Name = "Zombie Attack | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    local i8 = ESPLib.new {FetchEntryName = function(entry)
            return entry.Name
        end, Accent = RED}
    i8:SetGroupContainer(workspace.enemies)
    i8:Toggle(false)
    local i9 = ESPLib.new {FetchEntryName = function(entry)
            return entry.Name
        end, Accent = RED}
    i9:SetGroupContainer(workspace.BossFolder)
    i9:Toggle(false)
    local ia = 300
    local ib =
        AimbotLib.new(
        {aimbot_key = 0x02, fov_radius = ia, max_distance = 300, TraverseEntry = function(entry)
                return entry.Head or entry.HumanoidRootPart
            end}
    )
    ib:SetTargetPath(workspace.enemies)
    ib:FovToggle(false)
    ib:Toggle(false)
    local ic =
        AimbotLib.new(
        {aimbot_key = 0x02, fov_radius = ia, max_distance = 300, TraverseEntry = function(entry)
                return entry.Head or entry.HumanoidRootPart
            end}
    )
    ic:SetTargetPath(workspace.BossFolder)
    ic:FovToggle(false)
    ic:Toggle(false)
    local gC = hi:CreateTab("Aimbot")
    local hj = hi:CreateTab("Esp")
    local eG = hi:CreateTab("Gui Settings")
    local id =
        gC:CreateToggle(
        {Name = "Zombie Aimbot", CurrentValue = false, Callback = function(state)
                ib:Toggle(state)
            end}
    )
    local ie =
        gC:CreateToggle(
        {Name = "Boss Aimbot", CurrentValue = false, Callback = function(state)
                ic:Toggle(state)
            end}
    )
    local ig =
        gC:CreateToggle(
        {Name = "Aimbot Fov", CurrentValue = false, Callback = function(state)
                ib:FovToggle(state)
                ic:FovToggle(state)
            end}
    )
    local ih =
        gC:CreateSlider(
        {Name = "Aimbot Fov", Range = {10, 500}, Increment = 1, CurrentValue = ia, Callback = function(d)
                ib:SetFov(d)
                ic:SetFov(d)
            end}
    )
    local ii =
        hj:CreateToggle(
        {Name = "Zombie Esp", CurrentValue = false, Callback = function(state)
                i8:Toggle(state)
            end}
    )
    local ij =
        hj:CreateToggle(
        {Name = "Boss Esp", CurrentValue = false, Callback = function(state)
                i9:Toggle(state)
            end}
    )
    local hY =
        eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                window.toggleKey = eH
            end
        }
    )
    local hg =
        eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                hi:Destroy()
                i8:Destroy()
                i9:Destroy()
                ib:Destroy()
                ic:Destroy()
            end}
    )
    while true do
        i8:Step()
        i9:Step()
        ib:Update()
        ic:Update()
        hi:Step()
        wait(0.001)
    end
elseif game.GameId == ev then
    local hi =
        UILib:CreateWindow({Name = "H4X Aim Trainer | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    local gC = hi:CreateTab("Aimbot")
    local hj = hi:CreateTab("Esp")
    local eG = hi:CreateTab("Gui Settings")
    local ik = ESPLib.new {FetchEntryName = function(entry)
            return "Bot"
        end, Accent = RED}
    ik:SetGroupContainer(workspace.CurrentBots)
    ik:Toggle(false)
    local il =
        AimbotLib.new(
        {aimbot_key = 0x02, fov_radius = 250, max_distance = 700, TraverseEntry = function(entry)
                return entry.Head or entry.HumanoidRootPart
            end}
    )
    il:SetTargetPath(workspace.CurrentBots)
    il:FovToggle(false)
    il:Toggle(false)
    local im =
        gC:CreateToggle(
        {Name = "Bot Aimbot", CurrentValue = false, Callback = function(state)
                il:Toggle(state)
            end}
    )
    local io =
        hj:CreateToggle(
        {Name = "Bot Esp", CurrentValue = false, Callback = function(state)
                ik:Toggle(state)
            end}
    )
    local ip =
        gC:CreateToggle(
        {Name = "Bot Aimbot Fov", CurrentValue = false, Callback = function(state)
                il:FovToggle(state)
            end}
    )
    local iq =
        gC:CreateSlider(
        {Name = "Bot Aimbot Fov", Range = {10, 500}, Increment = 1, CurrentValue = 250, Callback = function(d)
                il:SetFov(d)
            end}
    )
    while true do
        ik:Step()
        il:Update()
        hi:Step()
        wait(0.001)
    end
elseif game.GameId == ew then
    local hi = UILib:CreateWindow({Name = "Doors | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    local hj = hi:CreateTab("Esp")
    local eG = hi:CreateTab("Gui Settings")
    local ir = ESPLib.new {TraverseEntry = function(entry)
            return entry.Door
        end, FetchEntryName = function(entry)
            return "Door: " .. entry.Name
        end, Accent = GREEN}
    ir:SetGroupContainer(workspace.CurrentRooms)
    ir:Toggle(false)
    local is =
        hj:CreateToggle(
        {Name = "Door Esp", CurrentValue = false, Callback = function(state)
                ir:Toggle(state)
            end}
    )
    local hg =
        eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                hi:Destroy()
                ir:Destroy()
            end}
    )
    local hY =
        eG:CreateTextbox(
        {
            Name = "Gui Toggle Key",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                window.toggleKey = eH
            end
        }
    )
    while true do
        ir:Step()
        hi:Step()
        wait(0.001)
    end
elseif game.GameId == ex then
    local hi =
        UILib:CreateWindow({Name = "The Final Stand | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    local gC = hi:CreateTab("Aimbot")
    local hj = hi:CreateTab("Esp")
    local eG = hi:CreateTab("Gui Settings")
    local i8 = ESPLib.new {FetchEntryName = function(entry)
            return entry.Name
        end, Accent = GREEN}
    i8:SetGroupContainer(workspace.Zombies)
    i8:Toggle(false)
    local ib =
        AimbotLib.new(
        {aimbot_key = 0x02, fov_radius = 250, max_distance = 700, TraverseEntry = function(entry)
                return entry.Head or entry.HumanoidRootPart
            end}
    )
    ib:SetTargetPath(workspace.Zombies)
    ib:FovToggle(false)
    ib:Toggle(false)
    local id =
        gC:CreateToggle(
        {Name = "Zombie Aimbot", CurrentValue = false, Callback = function(state)
                ib:Toggle(state)
            end}
    )
    local it =
        gC:CreateTextbox(
        {
            Name = "Zombie Aimbot Key",
            Default = "M2",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                local a9 = a7[eH:upper()]
                if a9 then
                    ib._aimbot_key = a9
                end
            end
        }
    )
    local iu =
        gC:CreateToggle(
        {Name = "Zombie Aimbot Fov", CurrentValue = false, Callback = function(state)
                ib:FovToggle(state)
            end}
    )
    local iv =
        gC:CreateSlider(
        {Name = "Zombie Aimbot Fov", Range = {10, 500}, Increment = 1, CurrentValue = 250, Callback = function(d)
                ib:SetFov(d)
            end}
    )
    local ii =
        hj:CreateToggle(
        {Name = "Zombie Esp broken", CurrentValue = false, Callback = function(state)
                i8:Toggle(state)
            end}
    )
    local hg =
        eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                hi:Destroy()
                i8:Destroy()
                ib:Destroy()
            end}
    )
    while true do
        i8:Step()
        ib:Update()
        hi:Step()
        wait(0.001)
    end
elseif game.GameId == ey then
    local hi =
        UILib:CreateWindow({Name = "BloxFruits | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"})
    local hj = hi:CreateTab("Esp")
    local eG = hi:CreateTab("Gui Settings")
    local iw = ESPLib.new {FetchEntryName = function(entry)
            return "Fruit"
        end, ValidateEntry = function(entry)
            return entry.Name == "Fruit"
        end, Accent = YELLOW}
    iw:SetGroupContainer(workspace)
    iw:Toggle(false)
    local ix =
        hj:CreateToggle(
        {Name = "Fruit Esp", CurrentValue = false, Callback = function(state)
                iw:Toggle(state)
            end}
    )
    local hg =
        eG:CreateButton(
        {Name = "Kill GUI", Callback = function()
                hi:Destroy()
                iw:Destroy()
            end}
    )
    local iy =
        eG:CreateTextbox(
        {
            Name = "Gui Toggle Keybind",
            Default = "K",
            PlaceholderText = "Press any key...",
            ClearTextOnFocus = true,
            Callback = function(eH)
                window.toggleKey = eH
            end
        }
    )
    while true do
        iw:Step()
        hi:Step()
        wait(0.001)
    end
else
    if game.GameId == ez then
        local hi =
            UILib:CreateWindow(
            {Name = "99 Nights In The Forest | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"}
        )
        local hj = hi:CreateTab("Esp")
        local eG = hi:CreateTab("Gui Settings")
        local iz = ESPLib.new {FetchEntryName = function(entry)
                return "Chest"
            end, ValidateEntry = function(entry)
                return entry.Name == "Item Chest" or entry.Name == "Item Chest2" or entry.Name == "Volcanic Chest1"
            end, Accent = YELLOW}
        iz:SetGroupContainer(game.Workspace.Items)
        iz:Toggle(false)
        local iA = ESPLib.new {FetchEntryName = function(entry)
                return "Coal"
            end, ValidateEntry = function(entry)
                return entry.Name == "Coal"
            end, Accent = BLACK}
        iA:SetGroupContainer(game.Workspace.Items)
        iA:Toggle(false)
        local iB = ESPLib.new {FetchEntryName = function(entry)
                return "Bolt"
            end, ValidateEntry = function(entry)
                return entry.Name == "Bolt"
            end, Accent = Color3.fromRGB(150, 150, 150)}
        iB:SetGroupContainer(game.Workspace.Items)
        iB:Toggle(false)
        local iC = ESPLib.new {FetchEntryName = function(entry)
                return "Revolver Ammo"
            end, ValidateEntry = function(entry)
                return entry.Name == "Revolver Ammo"
            end, Accent = Color3.fromRGB(255, 100, 0)}
        iC:SetGroupContainer(game.Workspace.Items)
        iC:Toggle(false)
        local iD = ESPLib.new {FetchEntryName = function(entry)
                return "Sheet Metal"
            end, ValidateEntry = function(entry)
                return entry.Name == "Sheet Metal"
            end, Accent = Color3.fromRGB(100, 100, 100)}
        iD:SetGroupContainer(game.Workspace.Items)
        iD:Toggle(false)
        local iE = ESPLib.new {FetchEntryName = function(entry)
                return "Fuel Canister"
            end, ValidateEntry = function(entry)
                return entry.Name == "Fuel Canister"
            end, Accent = Color3.fromRGB(255, 0, 0)}
        iE:SetGroupContainer(game.Workspace.Items)
        iE:Toggle(false)
        local iF = ESPLib.new {FetchEntryName = function(entry)
                return "Cultist"
            end, ValidateEntry = function(entry)
                return entry.Name == "Cultist"
            end, Accent = Color3.fromRGB(255, 0, 0)}
        iF:SetGroupContainer(game.Workspace.Items)
        iF:Toggle(false)
        local iG = ESPLib.new {FetchEntryName = function(entry)
                return "HallowenHouse"
            end, ValidateEntry = function(entry)
                print(entry.Name)
                return string.find(entry.Name, "Halloween") ~= nil or entry.Name == "Halloween House Cracky"
            end, TraverseEntry = function()
                return entry.Building
            end, Accent = Color3.fromRGB(255, 0, 0)}
        iG:SetGroupContainer(game.Workspace.Map.Landmark)
        iG:Toggle(false)
        local iH =
            hj:CreateToggle(
            {Name = "Chest Esp", CurrentValue = false, Callback = function(state)
                    iz:Toggle(state)
                end}
        )
        local iI =
            hj:CreateToggle(
            {Name = "Coal Esp", CurrentValue = false, Callback = function(state)
                    iA:Toggle(state)
                end}
        )
        local iJ =
            hj:CreateToggle(
            {Name = "Fuel Canister Esp", CurrentValue = false, Callback = function(state)
                    iE:Toggle(state)
                end}
        )
        local iK =
            hj:CreateToggle(
            {Name = "Bolt Esp", CurrentValue = false, Callback = function(state)
                    iB:Toggle(state)
                end}
        )
        local iL =
            hj:CreateToggle(
            {Name = "Revolver Ammo Esp", CurrentValue = false, Callback = function(state)
                    iC:Toggle(state)
                end}
        )
        local iM =
            hj:CreateToggle(
            {Name = "Sheet Metal Esp", CurrentValue = false, Callback = function(state)
                    iD:Toggle(state)
                end}
        )
        local iN =
            hj:CreateToggle(
            {Name = "Cultist Esp", CurrentValue = false, Callback = function(state)
                    iF:Toggle(state)
                end}
        )
        local iO =
            hj:CreateToggle(
            {Name = "Hallowen House Esp - maybe working?", CurrentValue = false, Callback = function(state)
                    iG:Toggle(state)
                end}
        )
        local hg =
            eG:CreateButton(
            {Name = "Kill GUI", Callback = function()
                    hi:Destroy()
                    iz:Destroy()
                end}
        )
        local iy =
            eG:CreateTextbox(
            {
                Name = "Gui Toggle Keybind",
                Default = "K",
                PlaceholderText = "Press any key...",
                ClearTextOnFocus = true,
                Callback = function(eH)
                    window.toggleKey = eH
                end
            }
        )
        while true do
            iz:Step()
            iA:Step()
            iB:Step()
            iD:Step()
            iC:Step()
            iF:Step()
            iE:Step()
            iG:Step()
            hi:Step()
            wait(0.001)
        end
    else
        if game.GameId == eA then
            local iP = false
            local iQ = Vector3.new(10, 10, 10)
            local dS = game:GetService("Players")
            local dT = dS.LocalPlayer
            local hi =
                UILib:CreateWindow(
                {Name = "Combat Warriors | discord.gg/5eQhEPZ4yJ", Theme = "Default", ToggleUIKeybind = "K"}
            )
            local iR = hi:CreateTab("Main")
            local iS =
                iR:CreateToggle(
                {Name = "Hitbox Expander", CurrentValue = false, Callback = function(state)
                        iP = state
                    end}
            )
            local iT =
                iR:CreateSlider(
                {Name = "Size", Range = {2, 50}, Increment = 1, CurrentValue = 10, Callback = function(d)
                        iQ = Vector3.new(d, d, d)
                    end}
            )
            while true do
                if iP then
                    for bf, a in pairs(dS:GetChildren()) do
                        if a ~= dT then
                            local eB = a.Character
                            if eB then
                                local iU = eB:FindFirstChild("Head")
                                if iU and iU.Parent then
                                    iU.Size = iQ
                                end
                            end
                        end
                    end
                end
                hi:Step()
                wait(0.001)
            end
        else
            local window =
                UILib:CreateWindow({Name = "universal script- Beta!!!", Theme = "Default", ToggleUIKeybind = "K"})
            local h6 = ESPLib.new {FetchEntryName = function(gr)
                    return "Player"
                end, Accent = GREEN}
            h6:SetGroupContainer(Players)
            h6:Toggle(false)
            local iV = AimbotLib.new({aimbot_key = 0x02, fov_radius = 250, max_distance = 700})
            iV:SetTargetPath(Players)
            iV:FovToggle(false)
            iV:Toggle(false)
            local gC = window:CreateTab("Aimbot - broken")
            local hj = window:CreateTab("Esp")
            local eG = window:CreateTab("Gui Settings")
            local iW = window:CreateTab("UiLib Features")
            local iX =
                gC:CreateToggle(
                {Name = "Aimbot", CurrentValue = false, Callback = function(state)
                        iV:Toggle(state)
                    end}
            )
            local iY =
                gC:CreateToggle(
                {Name = "Show FOV", CurrentValue = false, Callback = function(state)
                        iV:FovToggle(state)
                    end}
            )
            local gH =
                gC:CreateSlider(
                {Name = "FOV Radius", Range = {10, 500}, Increment = 1, CurrentValue = 250, Callback = function(d)
                        iV:SetFov(d)
                    end}
            )
            local iZ =
                gC:CreateSlider(
                {Name = "Aimbot Distance", Range = {10, 1000}, Increment = 1, CurrentValue = 700, Callback = function(d)
                        iV:SetMaxDistance(d)
                    end}
            )
            local i_ =
                gC:CreateTextbox(
                {
                    Name = "Aimbot Key",
                    Default = "0x02",
                    PlaceholderText = "Press any key...",
                    ClearTextOnFocus = true,
                    Callback = function(eH)
                        aimbot_key = key
                    end
                }
            )
            local j0 =
                hj:CreateToggle(
                {Name = "Esp", CurrentValue = false, Callback = function(state)
                        h6:Toggle(state)
                    end}
            )
            local j1 =
                hj:CreateColorPicker(
                {Name = "Esp Color", CurrentValue = Color3.fromRGB(255, 255, 255), Callback = function(d)
                        h6:SetAccent(d)
                    end}
            )
            local h9 =
                iW:CreateButton(
                {Name = "Example Button", Callback = function()
                        window:Notify({Title = "Example Button", Content = "Example Button Pressed", Duration = 6.5})
                    end}
            )
            local j2 =
                iW:CreateToggle(
                {Name = "Example Toggle", CurrentValue = false, Callback = function(state)
                    end}
            )
            local j3 =
                iW:CreateColorPicker(
                {Name = "Example Color Picker", CurrentValue = Color3.fromRGB(255, 255, 255), Callback = function(d)
                        window:Notify(
                            {Title = "Example Color Picker", Content = "Example Color Picker", Duration = 6.5}
                        )
                    end}
            )
            local j4 =
                iW:CreateDropdown(
                {
                    Name = "Multi Select Example Dropdown",
                    Options = {"Option 1", "Option 2", "Option 3", "Option 4"},
                    CurrentOption = {"Option 1"},
                    MultiSelect = true,
                    Callback = function(d)
                        window:Notify(
                            {Title = "Multi Select Example Dropdown", Content = d .. " is selected", Duration = 6.5}
                        )
                    end
                }
            )
            local j5 =
                iW:CreateSlider(
                {Name = "Example Slider", Range = {0, 100}, Increment = 1, CurrentValue = 50, Callback = function(d)
                        window:Notify({Title = "Example Slider", Content = "Example Slider is " .. d, Duration = 6.5})
                    end}
            )
            local j6 =
                iW:CreateTextbox(
                {
                    Name = "Example Textbox",
                    Default = "Example Text",
                    PlaceholderText = "Enter text...",
                    Callback = function(d)
                        window:Notify({Title = "Example Textbox", Content = "Example Textbox is " .. d, Duration = 6.5})
                    end
                }
            )
            local hY =
                eG:CreateTextbox(
                {Name = "Gui Toggle Key", Default = "K", PlaceholderText = "Press any key...", ClearTextOnFocus = true}
            )
            window:Notify(
                {Title = "Game not supported", Content = "Suggest game at discord.gg/5eQhEPZ4yJ", Duration = 6.5}
            )
            while true do
                window:Step()
                wait(0.001)
            end
            print("game is not supported. Suggest game at discord.gg/5eQhEPZ4yJ")
        end
    end
end
